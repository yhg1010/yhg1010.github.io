<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
    <meta name="keywords" content="Hexo Theme Keep">
    <meta name="description" content="Hexo Theme Keep">
    <meta name="author" content="calcium_oxide">
    
    <title>
        
            algorithm |
        
        calcium_oxide&#39;s blogs
    </title>
    
<link rel="stylesheet" href="/css/style.css">

    <link rel="shortcut icon" href="/images/image1.svg">
    
<link rel="stylesheet" href="/css/font-awesome.min.css">

    <script id="hexo-configurations">
    let KEEP = window.KEEP || {};
    KEEP.hexo_config = {"hostname":"yhg1010.github.io","root":"/","language":"en","path":"search.xml"};
    KEEP.theme_config = {"toc":{"enable":true,"number":false,"expand_all":false,"init_open":true},"style":{"primary_color":"#006699","avatar":"/images/image2.svg","favicon":"/images/image1.svg","article_img_align":"left","left_side_width":"260px","content_max_width":"920px","hover":{"shadow":false,"scale":false},"first_screen":{"enable":true,"background_img":"/images/bg.svg","description":"爱你所爱 行你所行 听从你心 无问西东"},"scroll":{"progress_bar":{"enable":false},"percent":{"enable":false}}},"local_search":{"enable":true,"preload":false},"code_copy":{"enable":true,"style":"mac"},"pjax":{"enable":false},"lazyload":{"enable":false},"version":"3.4.5"};
    KEEP.language_ago = {"second":"%s seconds ago","minute":"%s minutes ago","hour":"%s hours ago","day":"%s days ago","week":"%s weeks ago","month":"%s months ago","year":"%s years ago"};
  </script>
<meta name="generator" content="Hexo 6.2.0"></head>


<body>
<div class="progress-bar-container">
    

    
</div>


<main class="page-container">

    

    <div class="page-main-content">

        <div class="page-main-content-top">
            <header class="header-wrapper">

    <div class="header-content">
        <div class="left">
            
            <a class="logo-title" href="/">
                calcium_oxide&#39;s blogs
            </a>
        </div>

        <div class="right">
            <div class="pc">
                <ul class="menu-list">
                    
                        <li class="menu-item">
                            <a class=""
                               href="/"
                            >
                                HOME
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/archives"
                            >
                                ARCHIVES
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class="active"
                               href="/algorithm"
                            >
                                ALGORITHM
                            </a>
                        </li>
                    
                        <li class="menu-item">
                            <a class=""
                               href="/plan"
                            >
                                PLAN
                            </a>
                        </li>
                    
                    
                        <li class="menu-item search search-popup-trigger">
                            <i class="fas fa-search"></i>
                        </li>
                    
                </ul>
            </div>
            <div class="mobile">
                
                    <div class="icon-item search search-popup-trigger"><i class="fas fa-search"></i></div>
                
                <div class="icon-item menu-bar">
                    <div class="menu-bar-middle"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="header-drawer">
        <ul class="drawer-menu-list">
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/">HOME</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/archives">ARCHIVES</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class="active"
                       href="/algorithm">ALGORITHM</a>
                </li>
            
                <li class="drawer-menu-item flex-center">
                    <a class=""
                       href="/plan">PLAN</a>
                </li>
            
        </ul>
    </div>

    <div class="window-mask"></div>

</header>


        </div>

        <div class="page-main-content-middle">

            <div class="main-content">

                
                    <div class="fade-in-down-animation">
    <div class="page-template-container">
        
        
        <div class="page-template-content markdown-body">
            
                <h4 id="二分查找（逻辑统一）"><a href="#二分查找（逻辑统一）" class="headerlink" title="二分查找（逻辑统一）"></a>二分查找（逻辑统一）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binary_search</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>; </span><br><span class="line">    <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 直接返回</span></span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 直接返回</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">left_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 别返回，锁定左侧边界</span></span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后要检查 left 越界的情况</span></span><br><span class="line">    <span class="keyword">if</span> (left &gt;= nums.length || nums[left] != target)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> left;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">right_bound</span><span class="params">(<span class="type">int</span>[] nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> left = <span class="number">0</span>, right = nums.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right - left) / <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (nums[mid] &lt; target) &#123;</span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] &gt; target) &#123;</span><br><span class="line">            right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (nums[mid] == target) &#123;</span><br><span class="line">            <span class="comment">// 别返回，锁定右侧边界</span></span><br><span class="line">            left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 最后要检查 right 越界的情况</span></span><br><span class="line">    <span class="keyword">if</span> (right &lt; <span class="number">0</span> || nums[right] != target)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">return</span> right;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>例题（旋转数组）每次编码之前都得考虑边界条件，虽然不起眼但很重要！</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#数组可以分成两段，在每一段中分别进行搜索</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">search</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> target)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">if</span>(nums.<span class="built_in">size</span>() == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> nums[<span class="number">0</span>]==target?<span class="number">0</span>:<span class="number">-1</span>;</span><br><span class="line">      <span class="keyword">if</span>(!nums.<span class="built_in">size</span>())</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">      <span class="type">int</span> left = <span class="number">0</span>;</span><br><span class="line">      <span class="type">int</span> right = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">      <span class="keyword">while</span>(left &lt;= right) &#123;</span><br><span class="line">        <span class="type">int</span> mid = left + (right-left)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid] == target)</span><br><span class="line">            <span class="keyword">return</span> mid;</span><br><span class="line">        <span class="keyword">if</span>(nums[mid]&gt;=nums[<span class="number">0</span>]) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&gt;target &amp;&amp; target&gt;=nums[<span class="number">0</span>])</span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[mid]&lt;target &amp;&amp; target&lt;=nums[right])</span><br><span class="line">                left = mid + <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> </span><br><span class="line">                right = mid - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="最小公倍数，最大公因数"><a href="#最小公倍数，最大公因数" class="headerlink" title="最小公倍数，最大公因数"></a>最小公倍数，最大公因数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">gcd</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a% b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">lcm</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> a * b / <span class="built_in">gcd</span>(a, b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="筛法求质数"><a href="#筛法求质数" class="headerlink" title="筛法求质数"></a>筛法求质数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">countPrimes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=n<span class="number">-2</span>;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>||n==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">bool</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="literal">true</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>;i&lt;n;i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(dp[i])&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">2</span>*i;j&lt;n;j+=i)&#123;</span><br><span class="line">                    <span class="keyword">if</span>(dp[j])&#123;</span><br><span class="line">                        dp[j]=<span class="literal">false</span>;</span><br><span class="line">                    res--;</span><br><span class="line">                    &#125;</span><br><span class="line">                    </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="进制转换"><a href="#进制转换" class="headerlink" title="进制转换"></a>进制转换</h4><p>负数先转化为正数，再进行进制转化。</p>
<h4 id="阶乘尾部0的个数"><a href="#阶乘尾部0的个数" class="headerlink" title="阶乘尾部0的个数"></a>阶乘尾部0的个数</h4><p>每个尾部的 0 由 2 × 5 &#x3D; 10 而来，因此我们可以把阶乘的每一个元素拆成质数相乘，统计有<br>多少个 2 和 5。明显的，质因子 2 的数量远多于质因子 5 的数量，因此我们可以只统计阶乘结果<br>里有多少个质因子 5。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">trailingZeroes</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> n == <span class="number">0</span>? <span class="number">0</span>: n / <span class="number">5</span> + <span class="built_in">trailingZeroes</span>(n / <span class="number">5</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="fmod（x-y）"><a href="#fmod（x-y）" class="headerlink" title="fmod（x,y）"></a>fmod（x,y）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isPowerOfThree</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="built_in">fmod</span>(<span class="built_in">log10</span>(n) / <span class="built_in">log10</span>(<span class="number">3</span>), <span class="number">1</span>) == <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="随机取样算法"><a href="#随机取样算法" class="headerlink" title="随机取样算法"></a>随机取样算法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; origin;</span><br><span class="line">    <span class="built_in">Solution</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums):<span class="built_in">origin</span>(std::<span class="built_in">move</span>(nums)) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">reset</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> origin;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">shuffle</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">shuffled</span><span class="params">(origin)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(origin.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> origin;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=origin.<span class="built_in">size</span>()<span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">            <span class="built_in">swap</span>(shuffled[i],shuffled[<span class="built_in">rand</span>()%(i+<span class="number">1</span>)]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> shuffled;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>其中：<br>1.构造函数的三种写法</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">    <span class="type">int</span> m_score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 1. 无参构造函数</span></span><br><span class="line">    <span class="built_in">Student</span>() &#123;</span><br><span class="line">        m_age = <span class="number">18</span>;</span><br><span class="line">        m_score = <span class="number">99</span>;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;1. 无参构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">    <span class="type">int</span> m_score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 2. 一般构造函数</span></span><br><span class="line">    <span class="comment">// 初始化列表方式</span></span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> age, <span class="type">int</span> score) :</span><br><span class="line">        <span class="built_in">m_age</span>(age),</span><br><span class="line">        <span class="built_in">m_score</span>(score)</span><br><span class="line">        &#123;&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 内部赋值方式</span></span><br><span class="line">    <span class="built_in">Student</span>(<span class="type">int</span> age, <span class="type">int</span> score) &#123;</span><br><span class="line">        m_age = age;</span><br><span class="line">        m_score = score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Student</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> m_age;</span><br><span class="line">    <span class="type">int</span> m_score;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 3. 复制构造函数</span></span><br><span class="line">    <span class="built_in">Student</span>(Student&amp; s) &#123;</span><br><span class="line">        m_age = s.m_age;</span><br><span class="line">        m_score = s.m_score;</span><br><span class="line">        cout &lt;&lt; <span class="string">&quot;3.  复制构造函数&quot;</span> &lt;&lt; endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2.std::move()<br>作用主要是将左值转换为右值引用。<br>3.随机打乱算法</p>
<h4 id="按权重进行随机"><a href="#按权重进行随机" class="headerlink" title="按权重进行随机"></a>按权重进行随机</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; wei;</span><br><span class="line">    <span class="built_in">Solution</span>(vector&lt;<span class="type">int</span>&gt;&amp; w):<span class="built_in">wei</span>(w) &#123;</span><br><span class="line">        <span class="built_in">partial_sum</span>(wei.<span class="built_in">begin</span>(),wei.<span class="built_in">end</span>(),wei.<span class="built_in">begin</span>());</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pickIndex</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">lower_bound</span>(wei.<span class="built_in">begin</span>(),wei.<span class="built_in">end</span>(),<span class="built_in">rand</span>()%(wei.<span class="built_in">back</span>())+<span class="number">1</span>)-wei.<span class="built_in">begin</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>主要用到一个前缀和函数partial_sum（）和lower_bound()函数求一个不小于的下标。</p>
<h4 id="水库算法进行随机"><a href="#水库算法进行随机" class="headerlink" title="水库算法进行随机"></a>水库算法进行随机</h4><p>在面对一个不知道具体长度的随机问题时，可以使用水库算法：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    ListNode* head_;</span><br><span class="line">    <span class="built_in">Solution</span>(ListNode* head):<span class="built_in">head_</span>(head) &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">getRandom</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res=head_-&gt;val;</span><br><span class="line">        ListNode*tem=head_-&gt;next;</span><br><span class="line">        <span class="type">int</span> index=<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span>(tem)&#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">rand</span>()%index==<span class="number">0</span>)</span><br><span class="line">                res=tem-&gt;val;</span><br><span class="line">            index++;</span><br><span class="line">            tem=tem-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>核心思想就是每个元素都以1&#x2F;n的概率被随机到，证明是当前元素被选中并且之后的元素都没有被选中。</p>
<h4 id="string-类初始化"><a href="#string-类初始化" class="headerlink" title="string()类初始化"></a>string()类初始化</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">convertToTitle</span><span class="params">(<span class="type">int</span> columnNumber)</span> </span>&#123;</span><br><span class="line">        string s=<span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> a=columnNumber;</span><br><span class="line">        <span class="keyword">while</span>(a&gt;<span class="number">0</span>)&#123;</span><br><span class="line">            <span class="type">char</span> b=(a<span class="number">-1</span>)%<span class="number">26</span>+<span class="number">1</span>;</span><br><span class="line">            <span class="function">string <span class="title">tem</span><span class="params">(<span class="number">1</span>,b<span class="number">-1</span>+<span class="string">&#x27;A&#x27;</span>)</span></span>;</span><br><span class="line">            s=tem+s;</span><br><span class="line">            a=(a-b)/<span class="number">26</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>对于字符转换为字符串的问题，可以使用string(a,b)类，等价于一个有a个b的字符串。</p>
<h4 id="leetcode-快乐数"><a href="#leetcode-快乐数" class="headerlink" title="leetcode 快乐数"></a>leetcode 快乐数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">编写一个算法来判断一个数 n 是不是快乐数。</span><br><span class="line"></span><br><span class="line">「快乐数」定义为：</span><br><span class="line"></span><br><span class="line">对于一个正整数，每一次将该数替换为它每个位置上的数字的平方和。</span><br><span class="line">然后重复这个过程直到这个数变为 1，也可能是 无限循环 但始终变不到 1。</span><br><span class="line">如果 可以变为  1，那么这个数就是快乐数。</span><br><span class="line">如果 n 是快乐数就返回 <span class="literal">true</span> ；不是，则返回 <span class="literal">false</span> 。</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>对于这一类型的题目需要先进行枚举找出数列的规律，找出规律之后再进行求解。一般都是呈现两条或三条规律。<br>在此题中，一个数如果不是快乐数就陷入一个循环，否则就是快乐数。只需判断一个数是否出现在之前的序列中并且是否为1即可进行求解。</p>
<h4 id="最小移动和"><a href="#最小移动和" class="headerlink" title="最小移动和"></a>最小移动和</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定一个非空整数数组，找到使所有数组元素相等</span><br><span class="line">所需的最小移动数，其中每次移动可将选定的</span><br><span class="line">一个元素加1或减1。 </span><br><span class="line">您可以假设数组的长度最多为10000。</span><br></pre></td></tr></table></figure>
<p>可以通过证明得出中位数是最佳选择。</p>
<h4 id="通过一个随机函数获得另一个随机函数"><a href="#通过一个随机函数获得另一个随机函数" class="headerlink" title="通过一个随机函数获得另一个随机函数"></a>通过一个随机函数获得另一个随机函数</h4><p>最基本的做法就是枚举出所有的可能性然后进行分析。</p>
<h4 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">n&amp;(n-1)可以去除n的最低位上的1</span><br><span class="line">n&amp;(-n)可以得到最低位上的1</span><br></pre></td></tr></table></figure>
<p>巧妙运用：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组，这个数组里</span><br><span class="line">只有一个数次出现了一次，</span><br><span class="line">其余数字出现了两次，求这个只</span><br><span class="line">出现一次的数字。</span><br></pre></td></tr></table></figure>
<p>利用异或的性质。</p>
<h4 id="两个栈实现一个队列（面试真题）"><a href="#两个栈实现一个队列（面试真题）" class="headerlink" title="两个栈实现一个队列（面试真题）"></a>两个栈实现一个队列（面试真题）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">MyQueue</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; a;</span><br><span class="line">    stack&lt;<span class="type">int</span>&gt; b;</span><br><span class="line">    <span class="built_in">MyQueue</span>() &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">push</span><span class="params">(<span class="type">int</span> x)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!a.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            b.<span class="built_in">push</span>(a.<span class="built_in">top</span>());</span><br><span class="line">            a.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        b.<span class="built_in">push</span>(x);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">pop</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!b.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            a.<span class="built_in">push</span>(b.<span class="built_in">top</span>());</span><br><span class="line">            b.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> x=a.<span class="built_in">top</span>();</span><br><span class="line">        a.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">peek</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(!b.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            a.<span class="built_in">push</span>(b.<span class="built_in">top</span>());</span><br><span class="line">            b.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> a.<span class="built_in">top</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(a.<span class="built_in">empty</span>()&amp;&amp;b.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="优先队列"><a href="#优先队列" class="headerlink" title="优先队列"></a>优先队列</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">优先队列是在堆的基础上建立的，可以实现O(1)时间复杂度取出最大值，</span><br><span class="line">在O(logn)时间复杂度插入任意值。</span><br></pre></td></tr></table></figure>
<p>以下是关于堆的建立与操作：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Heap</span>&#123;</span><br><span class="line">    <span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; heap;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">top</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!heap.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> heap[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">int</span> x)</span></span>&#123;</span><br><span class="line">        heap.<span class="built_in">push_back</span>(x);</span><br><span class="line">        <span class="built_in">swim</span>(heap.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">delete_top</span><span class="params">()</span></span>&#123;</span><br><span class="line">        heap[<span class="number">0</span>]=heap[heap.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">        heap.<span class="built_in">pop_back</span>();</span><br><span class="line">        <span class="built_in">sink</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">empty_</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(heap.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">swim</span><span class="params">(<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(index/<span class="number">2</span>&gt;=<span class="number">0</span>&amp;&amp;heap[index/<span class="number">2</span>]&lt;heap[index])&#123;</span><br><span class="line">            <span class="built_in">swap</span>(heap[index/<span class="number">2</span>],heap[index]);</span><br><span class="line">            index=index/<span class="number">2</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">sink</span><span class="params">(<span class="type">int</span> index)</span></span>&#123;</span><br><span class="line">        <span class="keyword">while</span>(<span class="number">2</span>*index&lt;=heap.<span class="built_in">size</span>()<span class="number">-1</span>)&#123;</span><br><span class="line">            <span class="type">int</span> tem_index=index*<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>((tem_index+<span class="number">1</span>)&lt;=(heap.<span class="built_in">size</span>()<span class="number">-1</span>)&amp;&amp;heap[tem_index+<span class="number">1</span>]&gt;heap[tem_index]) tem_index++;</span><br><span class="line">            <span class="keyword">if</span>(heap[index]&lt;heap[tem_index])&#123;</span><br><span class="line">                <span class="built_in">swap</span>(heap[index],heap[tem_index]);</span><br><span class="line">                index=tem_index;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">例题：</span><br><span class="line">给你一个链表数组，每个链表都已经按升序排列。</span><br><span class="line">请你将所有链表合并到一个升序链表中，返回合并后的链表。</span><br></pre></td></tr></table></figure>
<p>此题可以引入优先队列，优先队列的方法如下：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, cmp&gt; q;</span><br><span class="line">自定义优先级：</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp</span> &#123;     </span><br><span class="line">　　<span class="function"><span class="keyword">operator</span> <span class="title">bool</span> <span class="params">()</span><span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>     </span></span><br><span class="line"><span class="function">　　</span>&#123;        </span><br><span class="line">　　　　 <span class="keyword">return</span>　x &gt; y;　　 <span class="comment">// x小的优先级高       　　　 		   </span></span><br><span class="line">　　　　 &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">empty</span>() 　　   如果队列为空，则返回真</span><br><span class="line"><span class="built_in">pop</span>()　　　　删除对顶元素，删除第一个元素</span><br><span class="line"><span class="built_in">push</span>() 　　     加入一个元素</span><br><span class="line"><span class="built_in">size</span>() 　　　  返回优先队列中拥有的元素个数</span><br><span class="line"><span class="built_in">top</span>() 　　　　返回优先队列对顶元素，返回优先队列中有最高优先级的元素</span><br><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以不断地维护优先队列，每次取出队首元素即为最小值，依次加入结果向量中即为最终结果。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">cmp</span>&#123;</span><br><span class="line">        <span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(ListNode*a,ListNode*b)</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> a-&gt;val&gt;b-&gt;val;</span><br><span class="line">        &#125;  </span><br><span class="line">    &#125;;</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        priority_queue&lt;ListNode*,vector&lt;ListNode*&gt;,cmp&gt; q;</span><br><span class="line">        <span class="keyword">for</span>(ListNode* list:lists)</span><br><span class="line">            <span class="keyword">if</span>(list)</span><br><span class="line">                q.<span class="built_in">push</span>(list);</span><br><span class="line">        ListNode* res=<span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode* tem=res;</span><br><span class="line">        <span class="keyword">while</span>(!q.<span class="built_in">empty</span>())&#123;</span><br><span class="line">            res-&gt;next=q.<span class="built_in">top</span>();</span><br><span class="line">            res=res-&gt;next;</span><br><span class="line">            q.<span class="built_in">pop</span>();</span><br><span class="line">            <span class="keyword">if</span>(res-&gt;next)</span><br><span class="line">                q.<span class="built_in">push</span>(res-&gt;next);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> tem-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">STL中的栈和队列都是以双端队列为基础建立的。</span><br><span class="line">双端队列可以实现两端进出元素。</span><br><span class="line">例题：</span><br><span class="line">给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。</span><br><span class="line">你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</span><br><span class="line">返回滑动窗口中的最大值。</span><br></pre></td></tr></table></figure>
<p>此题中可以通过滑动窗口这个要素来联想到双端队列，此处通过维护一个双端队列来保存每一阶段的最大值，每次清除掉最右端的小值，最左端的即为最大值。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        deque&lt;<span class="type">int</span>&gt; dp;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(!dp.<span class="built_in">empty</span>()&amp;&amp;dp.<span class="built_in">front</span>()&lt;=(i-k))</span><br><span class="line">                dp.<span class="built_in">pop_front</span>();</span><br><span class="line">            <span class="keyword">while</span>(!dp.<span class="built_in">empty</span>()&amp;&amp;nums[dp.<span class="built_in">back</span>()]&lt;nums[i])</span><br><span class="line">                dp.<span class="built_in">pop_back</span>();</span><br><span class="line">            dp.<span class="built_in">push_back</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(i&gt;=k<span class="number">-1</span>)</span><br><span class="line">                res.<span class="built_in">push_back</span>(nums[dp.<span class="built_in">front</span>()]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="hash-map"><a href="#hash-map" class="headerlink" title="hash_map"></a>hash_map</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定一个整数数组 nums 和一个整数目标值 target，请你在该数组中找出 和为目标值 target  的那 两个 整数，并返回它们的数组下标。</span><br><span class="line">你可以假设每种输入只会对应一个答案。但是，数组中同一个元素在答案里不能重复出现。</span><br><span class="line">你可以按任意顺序返回答案。</span><br></pre></td></tr></table></figure>
<p>题目不难，主要是用到hash_map进行优化，写之后发现hash_map不能存放key一样的元素，即使val不一样也不能存。</p>
<h4 id="前缀和与积分图"><a href="#前缀和与积分图" class="headerlink" title="前缀和与积分图"></a>前缀和与积分图</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">一维的前缀和，二维的积分图，都是把每个位置之前的一维线段或二维矩形预先存储，方便</span><br><span class="line">加速计算。如果需要对前缀和或积分图的值做寻址，则要存在哈希表里；如果要对每个位置记录</span><br><span class="line">前缀和或积分图的值，则可以储存到一维或二维数组里，也常常伴随着动态规划。</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">比较重要的一点是一个内置的求前缀和的函数：partial_sum(a.begin(),a.end(),b.begin());</span><br><span class="line">作用是将a的前缀和存入b中。</span><br></pre></td></tr></table></figure>
<p>一个很巧妙的结合散列表和前缀和的例题：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 nums 和一个整数 k ，请你统计并返回该数组中和为 k 的连续子数组的个数。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">subarraySum</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>,<span class="type">int</span>&gt; mp;</span><br><span class="line">        mp[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> tem=<span class="number">0</span>;<span class="type">int</span> res=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums)&#123;</span><br><span class="line">            tem+=i;</span><br><span class="line">            res+=mp[tem-k];</span><br><span class="line">            mp[tem]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">散列表的恰当使用将会对时间复杂度和题目的顺利解决产生极大的效果。</span><br></pre></td></tr></table></figure>

<h4 id="用空间换时间的完美例题"><a href="#用空间换时间的完美例题" class="headerlink" title="用空间换时间的完美例题"></a>用空间换时间的完美例题</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">超级丑数 是一个正整数，并满足其所有质因数都出现在质数数组 primes 中。</span><br><span class="line"></span><br><span class="line">给你一个整数 n 和一个整数数组 primes ，返回第 n 个 超级丑数 。</span><br><span class="line"></span><br><span class="line">题目数据保证第 n 个 超级丑数 在 32-bit 带符号整数范围内。</span><br></pre></td></tr></table></figure>
<p>这道题很显然就是可以通过枚举来解决，但由于数量级很大时间复杂度可能很高，有限队列也会出现这样的问题，因此考虑使用动态规划。当前的丑数可以通过对之前的记录的丑数进行排列组合，取最小值即为当前的丑数。新开一个数组记录最近的m个丑数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">nthSuperUglyNumber</span><span class="params">(<span class="type">int</span> n, vector&lt;<span class="type">int</span>&gt;&amp; primes)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span>&gt; <span class="title">dp</span><span class="params">(n+<span class="number">1</span>,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="type">int</span> m=primes.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span>&gt; <span class="title">points</span><span class="params">(m,<span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">long</span>&gt; <span class="title">nums</span><span class="params">(m,<span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">            <span class="type">long</span> <span class="type">long</span> min_=INT_MAX;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(min_&gt;nums[j])</span><br><span class="line">                    min_=nums[j];</span><br><span class="line">            &#125;</span><br><span class="line">            dp[i]=min_;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>;j&lt;nums.<span class="built_in">size</span>();j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]==min_)&#123;</span><br><span class="line">                    points[j]++;</span><br><span class="line">                    nums[j]=dp[points[j]]*primes[j];</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n];</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="优势洗牌"><a href="#优势洗牌" class="headerlink" title="优势洗牌"></a>优势洗牌</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给定两个大小相等的数组 A 和 B，A 相对于 B 的优势可以用满足 A[i] &gt; B[i] 的索引 i 的数目来描述。</span><br><span class="line"></span><br><span class="line">返回 A 的任意排列，使其相对于 B 的优势最大化。</span><br></pre></td></tr></table></figure>
<p>基本思路能够想到，就是对数组进行排序，当前元素不满足条件就往下走，可以实现元素价值利用最大化。主要有一点就是相同元素怎么处理，可以通过设置一个整数到数组的映射表，将满足条件的所有值都存储下来。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">advantageCount</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, vector&lt;<span class="type">int</span>&gt;&amp; nums2)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(nums1.size(),<span class="number">0</span>)</span></span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; remaining;</span><br><span class="line">        map&lt;<span class="type">int</span>,queue&lt;<span class="type">int</span>&gt;&gt; mp;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; nums2_;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums2)</span><br><span class="line">            nums2_.<span class="built_in">push_back</span>(i);</span><br><span class="line">        <span class="built_in">sort</span>(nums2_.<span class="built_in">begin</span>(),nums2_.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">sort</span>(nums1.<span class="built_in">begin</span>(),nums1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> j=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i:nums1)&#123;</span><br><span class="line">            <span class="keyword">if</span>(i&gt;nums2_[j])&#123;</span><br><span class="line">                mp[nums2_[j]].<span class="built_in">push</span>(i);</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                remaining.<span class="built_in">push_back</span>(i);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        map&lt;<span class="type">int</span>,queue&lt;<span class="type">int</span>&gt;&gt;::iterator it;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;nums2.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            it=mp.<span class="built_in">find</span>(nums2[i]);</span><br><span class="line">            <span class="keyword">if</span>(it!=mp.<span class="built_in">end</span>()&amp;&amp;!it-&gt;second.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                res[i]=it-&gt;second.<span class="built_in">front</span>();</span><br><span class="line">                it-&gt;second.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res[i]=remaining[remaining.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">                remaining.<span class="built_in">pop_back</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="线段树"><a href="#线段树" class="headerlink" title="线段树"></a>线段树</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">线段树能把一些对于区间（或者线段）的修改、维护，从O(N)的时间复杂度变成O（logN），对于频繁性的查询可以大大减小时间复杂度。</span><br><span class="line"> 通过分段引入树的结构大大减小数据的相关性，从而进一步减少区间修改查询的时间复杂度。</span><br></pre></td></tr></table></figure>
<p><a class="link"   target="_blank" rel="noopener" href="https://www.cnblogs.com/jason2003/p/9676729.html" >线段树详解<i class="fas fa-external-link-alt"></i></a></p>
<h4 id="KMP"><a href="#KMP" class="headerlink" title="KMP"></a>KMP</h4><p>目前看到了两种解法，其中一种是经典解法，另外一种很简单：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">无论是经典解法还是动态规划主要思想都是：</span><br><span class="line">（1）先建立一个记录下一次状态转移的位置的矩阵或向量</span><br><span class="line">（2）根据状态转移向量或矩阵进行匹配</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// class Solution &#123;</span></span><br><span class="line"><span class="comment">// public:</span></span><br><span class="line"><span class="comment">//     vector&lt; vector&lt;int&gt; &gt; dp;</span></span><br><span class="line"><span class="comment">//     int strStr(string haystack, string needle) &#123;</span></span><br><span class="line"><span class="comment">//         if(haystack.size()==0 &amp;&amp; needle.size()==0)</span></span><br><span class="line"><span class="comment">//             return 0;</span></span><br><span class="line"><span class="comment">//         else if(haystack.size()==0)</span></span><br><span class="line"><span class="comment">//             return -1;</span></span><br><span class="line"><span class="comment">//         else if(needle.size() == 0)</span></span><br><span class="line"><span class="comment">//             return 0;</span></span><br><span class="line"><span class="comment">//         dp.resize(50000,vector&lt;int&gt;(256,0));</span></span><br><span class="line"><span class="comment">//         kmp(needle);</span></span><br><span class="line"><span class="comment">//         return search(haystack,needle);</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line"><span class="comment">//     void kmp(string needle)&#123;</span></span><br><span class="line"><span class="comment">//         int m=needle.size();</span></span><br><span class="line"><span class="comment">//         dp[0][needle[0]] = 1;</span></span><br><span class="line"><span class="comment">//         int x = 0;</span></span><br><span class="line"><span class="comment">//         for(int i = 1;i &lt; m;i++)&#123;</span></span><br><span class="line"><span class="comment">//             for(int j = 0;j &lt; 256;j++)</span></span><br><span class="line"><span class="comment">//                 dp[i][j] = dp[x][j];</span></span><br><span class="line"><span class="comment">//             dp[i][needle[i]] = i+1;</span></span><br><span class="line"><span class="comment">//             x = dp[x][needle[i]];</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">//     int search(string haystack,string needle)&#123;</span></span><br><span class="line"><span class="comment">//         int m = needle.size();</span></span><br><span class="line"><span class="comment">//         int n = haystack.size();</span></span><br><span class="line"><span class="comment">//         int j = 0;</span></span><br><span class="line"><span class="comment">//         for(int i=0;i&lt;n;i++)&#123;</span></span><br><span class="line"><span class="comment">//             char ch = haystack[i];</span></span><br><span class="line"><span class="comment">//             j = dp[j][ch];</span></span><br><span class="line"><span class="comment">//             if(j == m)&#123;</span></span><br><span class="line"><span class="comment">//                 return i-m+1;</span></span><br><span class="line"><span class="comment">//             &#125;</span></span><br><span class="line"><span class="comment">//         &#125;</span></span><br><span class="line"><span class="comment">//         return -1;</span></span><br><span class="line"><span class="comment">//     &#125;</span></span><br><span class="line">    </span><br><span class="line"><span class="comment">// &#125;;</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">strStr</span><span class="params">(string haystack, string needle)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = haystack.<span class="built_in">size</span>(), m = needle.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span> (m == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">pi</span><span class="params">(m)</span></span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">1</span>, j = <span class="number">0</span>; i &lt; m; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; needle[i] != needle[j]) &#123;</span><br><span class="line">                j = pi[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (needle[i] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            pi[i] = j;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>; i &lt; n; i++) &#123;</span><br><span class="line">            <span class="keyword">while</span> (j &gt; <span class="number">0</span> &amp;&amp; haystack[i] != needle[j]) &#123;</span><br><span class="line">                j = pi[j - <span class="number">1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (haystack[i] == needle[j]) &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (j == m) &#123;</span><br><span class="line">                <span class="keyword">return</span> i - m + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>例：最长回文串<br>很简单的一道题，但是需要一些技巧，在写代码前好好思考一下是否有一些很简单的处理技巧，不要一味地套模板。而且必须要读清题意，比如这题就是不要求字母排列顺序，而不是最长回文子串。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//无论回文串的字母个数是奇数还是偶数，都可以取出偶数个字母构成回文串，对于奇数个字母再单独处理一下就可以。</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestPalindrome</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; count;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">char</span> c : s)</span><br><span class="line">            ++count[c];</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> p : count) &#123;</span><br><span class="line">            <span class="type">int</span> v = p.second;</span><br><span class="line">            ans += v / <span class="number">2</span> * <span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span> (v % <span class="number">2</span> == <span class="number">1</span> <span class="keyword">and</span> ans % <span class="number">2</span> == <span class="number">0</span>)</span><br><span class="line">                ++ans;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>最长回文子串：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">需要注意的点：</span><br><span class="line">1.遍历的时候以长度遍历，可以覆盖到所有的点。</span><br><span class="line">2.针对判断中多个条件的最好是拆分条件套层判断。</span><br><span class="line">3.O（n）算法马拉车暂时还没搞懂。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; dp;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">longestPalindrome</span><span class="params">(string s)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() &lt; <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line"></span><br><span class="line">        dp.<span class="built_in">resize</span>(s.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(s.<span class="built_in">size</span>() + <span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="type">int</span> len = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> res_index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; s.<span class="built_in">size</span>(); i++)</span><br><span class="line">            dp[i][i] = <span class="number">1</span>;</span><br><span class="line">        <span class="comment">// for(int i=0;i&lt;s.size()-1;i++)</span></span><br><span class="line">        <span class="comment">//     if(s[i]==s[i+1])</span></span><br><span class="line">        <span class="comment">//         dp[i][i+1]=1;</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> len_ = <span class="number">2</span>; len_ &lt;= s.<span class="built_in">size</span>(); len_++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> index = <span class="number">0</span>; index &lt; s.<span class="built_in">size</span>(); index++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="type">int</span> tem_right = len_ + index - <span class="number">1</span>;</span><br><span class="line">                <span class="keyword">if</span> (tem_right &gt;= s.<span class="built_in">size</span>())</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span> (s[index] != s[tem_right])</span><br><span class="line">                    dp[index][tem_right] = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span> (tem_right - index &lt; <span class="number">3</span>)</span><br><span class="line">                        dp[index][tem_right] = <span class="number">1</span>;</span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                    &#123;</span><br><span class="line">                        dp[index][tem_right] = dp[index + <span class="number">1</span>][tem_right - <span class="number">1</span>];</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (len_ &gt; len &amp;&amp; dp[index][tem_right])</span><br><span class="line">                &#123;</span><br><span class="line">                    len = len_;</span><br><span class="line">                    res_index = index;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> s.<span class="built_in">substr</span>(res_index, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>反转链表</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">反转链表是面试中最长考的一道题，必须要牢牢记住。</span><br><span class="line">实现要点就是头插法，一个尾指针从链表尾部出发不断向前走，头指针不断往后走，走完尾指针就变成头指针。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">reverseList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        ListNode *pre=<span class="literal">nullptr</span>, *tem;</span><br><span class="line">        <span class="keyword">while</span>(head)&#123;</span><br><span class="line">            tem=head-&gt;next;</span><br><span class="line">            head-&gt;next=pre;</span><br><span class="line">            pre=head;</span><br><span class="line">            head=tem;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> pre;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="股票交易"><a href="#股票交易" class="headerlink" title="股票交易"></a>股票交易</h4><p>（基）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxProfit</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; prices)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> preMin = prices[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;prices.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(prices[i]-preMin &gt; res) </span><br><span class="line">                res = prices[i]-preMin;</span><br><span class="line">            <span class="keyword">if</span>(prices[i] &lt; preMin) &#123;</span><br><span class="line">                preMin = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="快慢指针"><a href="#快慢指针" class="headerlink" title="快慢指针"></a>快慢指针</h4><p>环形链表判断（基）</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        ListNode *first = head-&gt;next-&gt;next;</span><br><span class="line">        ListNode *second = head-&gt;next;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span>(first &amp;&amp; first-&gt;next &amp;&amp; first != second) &#123;</span><br><span class="line">            first = first-&gt;next-&gt;next;</span><br><span class="line">            second = second-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(!first || !first-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>环形链表判断（Ⅱ）</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">detectCycle</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!head || !head-&gt;next)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *firstNode = head-&gt;next-&gt;next;</span><br><span class="line">        ListNode *secondNode = head-&gt;next;</span><br><span class="line">        <span class="keyword">while</span>(firstNode &amp;&amp; firstNode-&gt;next &amp;&amp; firstNode!=secondNode) &#123;</span><br><span class="line">            firstNode = firstNode-&gt;next-&gt;next;</span><br><span class="line">            secondNode = secondNode-&gt;next;</span><br><span class="line">        &#125;    </span><br><span class="line">       </span><br><span class="line">        <span class="keyword">if</span>(firstNode &amp;&amp; firstNode-&gt;next) &#123;</span><br><span class="line">            firstNode = head;</span><br><span class="line">            <span class="keyword">while</span>(firstNode != secondNode) &#123;</span><br><span class="line">                firstNode = firstNode-&gt;next;</span><br><span class="line">                secondNode = secondNode-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">return</span> firstNode;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h4 id="二叉树的锯齿形层序遍历"><a href="#二叉树的锯齿形层序遍历" class="headerlink" title="二叉树的锯齿形层序遍历"></a>二叉树的锯齿形层序遍历</h4><p>第一次做想套用层序遍历的方法，记录一下每一层的遍历顺序，后来发现有点麻烦。实际动手做发现用两个栈来实现更方便，不同顺序遍历对应了两个不同的栈。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">zigzagLevelOrder</span>(TreeNode* root) &#123;</span><br><span class="line">        stack&lt;TreeNode*&gt; q1;</span><br><span class="line">        stack&lt;TreeNode*&gt; q2;</span><br><span class="line">        q1.<span class="built_in">push</span>(root);</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; newLine;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="type">int</span> nextNum = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(!q1.<span class="built_in">empty</span>() || !q2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            TreeNode* tem;</span><br><span class="line">            <span class="keyword">if</span>(flag==<span class="number">0</span>) &#123;</span><br><span class="line">                <span class="keyword">while</span>(!q1.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    tem = q1.<span class="built_in">top</span>();</span><br><span class="line">                    q1.<span class="built_in">pop</span>();</span><br><span class="line">                    newLine.<span class="built_in">push_back</span>(tem-&gt;val);</span><br><span class="line">                    <span class="keyword">if</span>(tem-&gt;left) &#123;</span><br><span class="line">                        q2.<span class="built_in">push</span>(tem-&gt;left);</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">if</span>(tem-&gt;right)</span><br><span class="line">                        q2.<span class="built_in">push</span>(tem-&gt;right);</span><br><span class="line">                &#125;</span><br><span class="line">                flag = <span class="number">1</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(newLine);</span><br><span class="line">                newLine.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">while</span>(!q2.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">                    tem = q2.<span class="built_in">top</span>();</span><br><span class="line">                    q2.<span class="built_in">pop</span>();</span><br><span class="line">                    newLine.<span class="built_in">push_back</span>(tem-&gt;val);</span><br><span class="line">                    <span class="keyword">if</span>(tem-&gt;right)</span><br><span class="line">                        q1.<span class="built_in">push</span>(tem-&gt;right);</span><br><span class="line">                    <span class="keyword">if</span>(tem-&gt;left)</span><br><span class="line">                        q1.<span class="built_in">push</span>(tem-&gt;left);</span><br><span class="line">                &#125;</span><br><span class="line">                flag = <span class="number">0</span>;</span><br><span class="line">                res.<span class="built_in">push_back</span>(newLine);</span><br><span class="line">                newLine.<span class="built_in">clear</span>();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="LRU"><a href="#LRU" class="headerlink" title="LRU"></a>LRU</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">list的splice用法</span><br><span class="line">splice(position, list2): 将list2中的所有元素剪贴到list1的position位置；</span><br><span class="line">splice(position, list2, iter): 将list2中某个位置的迭代器iter指向的元素剪贴到list1中的position位置；</span><br><span class="line">splice(position, list2, iter1, iter2): 将list2中的某一段位置iter1 ~ iter2的元素剪贴到list1中的position位置</span><br><span class="line"></span><br><span class="line">list通过back()索引到最后一个值</span><br></pre></td></tr></table></figure>

<p><em>面试高频题</em></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//哈希表的作用基本上就是以O（1）的时间执行查找操作，涉及到O（1）基本上要考虑哈希表</span></span><br><span class="line"><span class="comment">//list可以实现拼接操作</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">LRUCache</span></span><br><span class="line">&#123;</span><br><span class="line">    list&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; cache;</span><br><span class="line">    unordered_map&lt;<span class="type">int</span>, list&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;::iterator&gt; mp;</span><br><span class="line">    <span class="type">int</span> cacheSize;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">LRUCache</span>(<span class="type">int</span> capacity):<span class="built_in">cacheSize</span>(capacity)  &#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">get</span><span class="params">(<span class="type">int</span> key)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = mp.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(it == mp.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cache.<span class="built_in">splice</span>(cache.<span class="built_in">begin</span>(), cache, it-&gt;second);</span><br><span class="line">        <span class="keyword">return</span> it-&gt;second-&gt;second;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">put</span><span class="params">(<span class="type">int</span> key, <span class="type">int</span> value)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="keyword">auto</span> it = mp.<span class="built_in">find</span>(key);</span><br><span class="line">        <span class="keyword">if</span>(it != mp.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            cache.<span class="built_in">splice</span>(cache.<span class="built_in">begin</span>(), cache, it-&gt;second);</span><br><span class="line">            it-&gt;second-&gt;second = value;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cache.<span class="built_in">insert</span>(cache.<span class="built_in">begin</span>(), <span class="built_in">make_pair</span>(key, value));</span><br><span class="line">        mp[key] = cache.<span class="built_in">begin</span>();</span><br><span class="line">        <span class="keyword">if</span>(cache.<span class="built_in">size</span>() &gt; cacheSize) &#123;</span><br><span class="line">            mp.<span class="built_in">erase</span>(cache.<span class="built_in">back</span>().first);</span><br><span class="line">            cache.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="第K大的数"><a href="#第K大的数" class="headerlink" title="第K大的数"></a>第K大的数</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//可以直接排序得到</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findKthLargest</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> i: nums) &#123;</span><br><span class="line">            <span class="keyword">auto</span> it = mp.<span class="built_in">find</span>(i);</span><br><span class="line">            <span class="keyword">if</span>(it == mp.<span class="built_in">end</span>())</span><br><span class="line">                mp[i] = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                mp[i]++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">auto</span> it = mp.<span class="built_in">end</span>();</span><br><span class="line">        it--;</span><br><span class="line">        <span class="keyword">for</span>(it; it!=mp.<span class="built_in">begin</span>(); it--) &#123;</span><br><span class="line">            cnt += it-&gt;second;</span><br><span class="line">            <span class="keyword">if</span>(cnt &gt;= k)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> it-&gt;first;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="k个一组翻转链表"><a href="#k个一组翻转链表" class="headerlink" title="k个一组翻转链表"></a>k个一组翻转链表</h4><p>给你链表的头节点 head ，每 k 个节点一组进行翻转，请你返回修改后的链表。</p>
<p>k 是一个正整数，它的值小于或等于链表的长度。如果节点总数不是 k 的整数倍，那么请将最后剩余的节点保持原有顺序。</p>
<p>你不能只是单纯的改变节点内部的值，而是需要实际进行节点交换。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归的思路很显然，关键是要注意细节</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseKGroup</span><span class="params">(ListNode *head, <span class="type">int</span> k)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        ListNode *res = <span class="literal">NULL</span>;</span><br><span class="line">        ListNode *tem = head;</span><br><span class="line">        ListNode *preHead = head;</span><br><span class="line">        <span class="type">int</span> cnt = k;</span><br><span class="line">        <span class="keyword">while</span> (cnt-- &amp;&amp; tem)</span><br><span class="line">        &#123;</span><br><span class="line">            ListNode* newNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">            newNode-&gt;val = tem-&gt;val;</span><br><span class="line">            newNode-&gt;next = res;</span><br><span class="line">            <span class="keyword">if</span>(cnt == (k<span class="number">-1</span>)) &#123;</span><br><span class="line">                preHead = newNode;</span><br><span class="line">            &#125;</span><br><span class="line">            res = newNode;</span><br><span class="line">            tem = tem-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (tem)</span><br><span class="line">        &#123;</span><br><span class="line">            preHead-&gt;next = <span class="built_in">reverseKGroup</span>(tem, k);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(!tem &amp;&amp; cnt != <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="指定起始和终止结点进行反转链表"><a href="#指定起始和终止结点进行反转链表" class="headerlink" title="指定起始和终止结点进行反转链表"></a>指定起始和终止结点进行反转链表</h4><p>给你单链表的头指针 head 和两个整数 left 和 right ，其中 left &lt;&#x3D; right 。请你反转从位置 left 到位置 right 的链表节点，返回 反转后的链表 。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这类型有一个通用的策略就是设置一个虚拟头结点，可以解决头结点的计算问题。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode *<span class="title">reverseBetween</span><span class="params">(ListNode *head, <span class="type">int</span> left, <span class="type">int</span> right)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 设置 dummyNode 是这一类问题的一般做法</span></span><br><span class="line">        ListNode *dummyNode = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        dummyNode-&gt;next = head;</span><br><span class="line">        ListNode *pre = dummyNode;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; left - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            pre = pre-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode *cur = pre-&gt;next;</span><br><span class="line">        ListNode *next;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; right - left; i++) &#123;</span><br><span class="line">            next = cur-&gt;next;</span><br><span class="line">            cur-&gt;next = next-&gt;next;</span><br><span class="line">            next-&gt;next = pre-&gt;next;</span><br><span class="line">            pre-&gt;next = next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dummyNode-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="三数之和"><a href="#三数之和" class="headerlink" title="三数之和"></a>三数之和</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//先枚举一个数，转化为两数之和问题，通过排序以及一些剪枝操作可以降低时间复杂度</span></span><br><span class="line"><span class="comment">//排除相同组合的操作就是排序后枚举，跳过之前枚举过的元素</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">threeSum</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="built_in">sort</span>(nums.<span class="built_in">begin</span>(), nums.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> first = <span class="number">0</span>; first &lt; n; first++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(first &gt; <span class="number">0</span> &amp;&amp; nums[first] == nums[first<span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="type">int</span> target = -nums[first];</span><br><span class="line">            <span class="type">int</span> third = n - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> second = (first + <span class="number">1</span>); second &lt; n; second++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(second &gt; (first + <span class="number">1</span>) &amp;&amp; nums[second] == nums[second - <span class="number">1</span>])</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="comment">//int third = n - 1;</span></span><br><span class="line">                <span class="comment">//cout &lt;&lt; second &lt;&lt; &quot; &quot; &lt;&lt; n &lt;&lt; endl;</span></span><br><span class="line">                <span class="keyword">while</span>(second &lt; third &amp;&amp; (nums[second] + nums[third]) &gt; target)</span><br><span class="line">                    third--;</span><br><span class="line">                <span class="keyword">if</span>(second == third)</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                <span class="keyword">if</span>((nums[second] + nums[third]) == target)</span><br><span class="line">                    res.<span class="built_in">push_back</span>(&#123;nums[first], nums[second], nums[third]&#125;);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="快速排序（快速版）"><a href="#快速排序（快速版）" class="headerlink" title="快速排序（快速版）"></a>快速排序（快速版）</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//三段式，第一段总的排序框架，第二段（通过随机调换打乱顺序），第三段快速排序并找出分段点</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> tem = nums[r];</span><br><span class="line">        <span class="type">int</span> i = l<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> j = l; j &lt;= r<span class="number">-1</span>; j++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums[j] &lt;= tem) &#123;</span><br><span class="line">                i++;</span><br><span class="line">                <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">swap</span>(nums[i+<span class="number">1</span>], nums[r]);</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">random_partition</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = <span class="built_in">rand</span>() % (r-l+<span class="number">1</span>) + l;</span><br><span class="line">        <span class="built_in">swap</span>(nums[r], nums[i]);</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">partition</span>(nums, l, r);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">random_quicksort</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &lt; r) &#123;</span><br><span class="line">            <span class="type">int</span> pos = <span class="built_in">random_partition</span>(nums, l, r);</span><br><span class="line">            <span class="built_in">random_quicksort</span>(nums, l, pos<span class="number">-1</span>);</span><br><span class="line">            <span class="built_in">random_quicksort</span>(nums, pos+<span class="number">1</span>, r);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sortArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">srand</span>((<span class="type">unsigned</span>)<span class="built_in">time</span>(<span class="literal">NULL</span>));</span><br><span class="line">        <span class="built_in">random_quicksort</span>(nums, <span class="number">0</span>, nums.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="二叉树的最近祖先"><a href="#二叉树的最近祖先" class="headerlink" title="二叉树的最近祖先"></a>二叉树的最近祖先</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">    是公共节点的有两种情况：</span></span><br><span class="line"><span class="comment">    1.左子树上和右子树上同时出现了p和q。</span></span><br><span class="line"><span class="comment">    2.当前节点就是p或q。</span></span><br><span class="line"><span class="comment">    不用考虑最低的公共节点，直接判断是否是公共节点即可。</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    TreeNode* ans;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">dfs</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root == <span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">bool</span> lson = <span class="built_in">dfs</span>(root-&gt;left, p, q);</span><br><span class="line">        <span class="type">bool</span> rson = <span class="built_in">dfs</span>(root-&gt;right, p, q);</span><br><span class="line">        cout &lt;&lt; root-&gt;val &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; lson &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; rson &lt;&lt; endl;</span><br><span class="line">        <span class="keyword">if</span> ((lson &amp;&amp; rson) || ((root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val) &amp;&amp; (lson || rson))) &#123;</span><br><span class="line">            ans = root;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">return</span> lson || rson || (root-&gt;val == p-&gt;val || root-&gt;val == q-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">dfs</span>(root, p, q);</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>这道题最初的想法也是递归做，记录两个结点的深度，根据深度来回溯到最近一个公共结点，后来发现做不下去。仔细想想这道题确实应该是用递归来做，首先是想好公共结点的定义是什么，判断一个节点是不是公共结点只需判断<strong>该结点下是否同时存在两个结点或者该结点就是两个结点之一并且左子树或右子树存在另一个结点</strong>。而且最关键的一点是这道题必须得用后序遍历，只有通过后序遍历之前的结点才能都走一遍。</p>
<h4 id="合并两个有序数组"><a href="#合并两个有序数组" class="headerlink" title="合并两个有序数组"></a>合并两个有序数组</h4><p>有时候不要死板地从一个方向去考虑，换个方向可能问题更简单</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums1, <span class="type">int</span> m, vector&lt;<span class="type">int</span>&gt;&amp; nums2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> index1 = m<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> index2 = n<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> index = m+n<span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> res;</span><br><span class="line">        <span class="keyword">while</span>(index1&gt;=<span class="number">0</span> || index2&gt;=<span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(index1==<span class="number">-1</span>) &#123;</span><br><span class="line">                res = nums2[index2--];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(index2==<span class="number">-1</span>) &#123;</span><br><span class="line">                res = nums1[index1--];</span><br><span class="line">            &#125; <span class="keyword">else</span> <span class="keyword">if</span>(nums1[index1]&gt;nums2[index2]) &#123;</span><br><span class="line">                res = nums1[index1--];</span><br><span class="line">            &#125; <span class="keyword">else</span>&#123;</span><br><span class="line">                res = nums2[index2--];</span><br><span class="line">            &#125;</span><br><span class="line">            nums1[index--] = res;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="合并k个升序链表"><a href="#合并k个升序链表" class="headerlink" title="合并k个升序链表"></a>合并k个升序链表</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">mergeKLists</span><span class="params">(vector&lt;ListNode*&gt;&amp; lists)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(lists.<span class="built_in">empty</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;lists.<span class="built_in">size</span>(); i++)</span><br><span class="line">            <span class="keyword">if</span>(lists[i]!=<span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=lists.<span class="built_in">size</span>())</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        <span class="type">int</span> min_ = <span class="number">1e5</span>;</span><br><span class="line">        ListNode* min_node;</span><br><span class="line">        <span class="type">int</span> index;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;lists.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(lists[i]==<span class="literal">NULL</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">if</span>(lists[i]-&gt;val &lt; min_) &#123;</span><br><span class="line">                min_ = lists[i]-&gt;val;</span><br><span class="line">                min_node = lists[i];</span><br><span class="line">                index = i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        lists[index] = lists[index]-&gt;next;</span><br><span class="line">        min_node-&gt;next = <span class="built_in">mergeKLists</span>(lists);</span><br><span class="line">        <span class="keyword">return</span> min_node;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="全排列"><a href="#全排列" class="headerlink" title="全排列"></a>全排列</h4><p>这里有一个注意点，就是vector的clear方法是将vector的size设置为0，capacity不变，而size是vector当前存储的元素个数，capacity指容器在内存中申请的这片区域所能容纳的元素个数。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; tem;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> index, vector&lt;<span class="type">int</span>&gt;&amp; visited)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(index&gt;=nums.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(tem);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;nums.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(visited[i]==<span class="number">0</span>) &#123;</span><br><span class="line">                tem.<span class="built_in">push_back</span>(nums[i]);</span><br><span class="line">                visited[i] = <span class="number">1</span>;</span><br><span class="line">                index++;</span><br><span class="line">                <span class="built_in">solve</span>(nums, index, visited);</span><br><span class="line">                visited[i] = <span class="number">0</span>;</span><br><span class="line">                tem.<span class="built_in">pop_back</span>();</span><br><span class="line">                index--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">permute</span>(vector&lt;<span class="type">int</span>&gt;&amp; nums) &#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">visited</span><span class="params">(nums.size(), <span class="number">0</span>)</span></span>;</span><br><span class="line">        <span class="built_in">solve</span>(nums, <span class="number">0</span>, visited);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="螺旋矩阵"><a href="#螺旋矩阵" class="headerlink" title="螺旋矩阵"></a>螺旋矩阵</h4><p>给你一个 <code>m</code> 行 <code>n</code> 列的矩阵 <code>matrix</code> ，请按照 <strong>顺时针螺旋顺序</strong> ，返回矩阵中的所有元素。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这道题比较有意思，如果按正常思维模拟可能会非常麻烦，主要麻烦的点就是遍历方向的处理，因此这里引入了方向矩阵，可以设置边界条件自动化自定义的决定遍历的顺序。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">static</span> <span class="keyword">constexpr</span> <span class="type">int</span> directions[<span class="number">4</span>][<span class="number">2</span>] = &#123;&#123;<span class="number">0</span>, <span class="number">1</span>&#125;, &#123;<span class="number">1</span>, <span class="number">0</span>&#125;, &#123;<span class="number">0</span>, <span class="number">-1</span>&#125;, &#123;<span class="number">-1</span>, <span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">spiralOrder</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; matrix)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (matrix.<span class="built_in">size</span>() == <span class="number">0</span> || matrix[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> &#123;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="type">int</span> rows = matrix.<span class="built_in">size</span>(), columns = matrix[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt;&gt; <span class="built_in">visited</span>(rows, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(columns));</span><br><span class="line">        <span class="type">int</span> total = rows * columns;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">order</span><span class="params">(total)</span></span>;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> row = <span class="number">0</span>, column = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> directionIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; total; i++) &#123;</span><br><span class="line">            order[i] = matrix[row][column];</span><br><span class="line">            visited[row][column] = <span class="literal">true</span>;</span><br><span class="line">            <span class="type">int</span> nextRow = row + directions[directionIndex][<span class="number">0</span>], nextColumn = column + directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">if</span> (nextRow &lt; <span class="number">0</span> || nextRow &gt;= rows || nextColumn &lt; <span class="number">0</span> || nextColumn &gt;= columns || visited[nextRow][nextColumn]) &#123;</span><br><span class="line">                directionIndex = (directionIndex + <span class="number">1</span>) % <span class="number">4</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            row += directions[directionIndex][<span class="number">0</span>];</span><br><span class="line">            column += directions[directionIndex][<span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> order;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="字符串相加"><a href="#字符串相加" class="headerlink" title="字符串相加"></a>字符串相加</h4><p>给定两个字符串形式的非负整数 num1 和num2 ，计算它们的和并同样以字符串形式返回。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">这道题就是高精度相加。</span><br><span class="line">需要注意的点是一些字符串和字符数组的函数：</span><br><span class="line">字符串转置：reverse(s.begin(), s.end())</span><br><span class="line">字符数组转字符串：string s(&amp;res[0], &amp;res[index])</span><br><span class="line">字符串转字符数组：strcpy(buf, s.c_str())</span><br><span class="line">字符串转数字：x=atoi(a)</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">addStrings</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">reverse</span>(num1.<span class="built_in">begin</span>(), num1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(num2.<span class="built_in">begin</span>(), num2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> len1 = num1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> len2 = num2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> len = len1&gt;len2?len1:len2;</span><br><span class="line">        <span class="type">char</span> res[len+<span class="number">1</span>];</span><br><span class="line">        <span class="type">int</span> numa, numb, numc;</span><br><span class="line">        <span class="type">int</span> next = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;len1)</span><br><span class="line">                numa = num1[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            <span class="keyword">if</span>(i&lt;len2)</span><br><span class="line">                numb = num2[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            numc = (numa + numb + next) % <span class="number">10</span>;</span><br><span class="line">            next = (numa + numb + next) / <span class="number">10</span>;</span><br><span class="line">            res[i] = numc + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            numa = <span class="number">0</span>; numb = <span class="number">0</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(next) &#123;</span><br><span class="line">            res[index] = next + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        <span class="function">string <span class="title">s</span><span class="params">(&amp;res[<span class="number">0</span>], &amp;res[index])</span></span>;</span><br><span class="line">        <span class="built_in">reverse</span>(s.<span class="built_in">begin</span>(), s.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> s;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="最长递增子序列"><a href="#最长递增子序列" class="headerlink" title="最长递增子序列"></a>最长递增子序列</h4><p>记录以当前元素为子序列结尾元素的最长子序列长度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLIS</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">sz</span><span class="params">(len, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;len; i++) &#123;</span><br><span class="line">            <span class="type">int</span> max_res = <span class="number">1</span>;</span><br><span class="line">            <span class="type">int</span> index = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;i; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums[j]&lt;nums[i] &amp;&amp; sz[j]&gt;=max_res) &#123;</span><br><span class="line">                    max_res = sz[j];</span><br><span class="line">                    index = j;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(index!=<span class="number">-1</span>)</span><br><span class="line">                sz[i] = max_res+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                sz[i] = max_res;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;sz.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(res&lt;sz[i])</span><br><span class="line">                res = sz[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="接露水"><a href="#接露水" class="headerlink" title="接露水"></a>接露水</h4><p>这道题有个很巧妙的动态规划的解法，对于每个位置计算这个位置的露水数量，只要得到该位置所在区间内的最短的边缘部分就可以。这样就可以用动态规划得到最左边和最右边的最大边缘的高度。</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">trap</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; height)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = height.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> leftmax[len];</span><br><span class="line">        <span class="type">int</span> rightmax[len];</span><br><span class="line">        leftmax[<span class="number">0</span>] = height[<span class="number">0</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;len; i++) &#123;</span><br><span class="line">            leftmax[i] = <span class="built_in">max</span>(leftmax[i<span class="number">-1</span>], height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        rightmax[len<span class="number">-1</span>] = height[len<span class="number">-1</span>];</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=len<span class="number">-2</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            rightmax[i] = <span class="built_in">max</span>(rightmax[i+<span class="number">1</span>], height[i]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++) </span><br><span class="line">            res += <span class="built_in">min</span>(leftmax[i], rightmax[i]) - height[i];</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="二叉树中的最大路径和"><a href="#二叉树中的最大路径和" class="headerlink" title="二叉树中的最大路径和"></a>二叉树中的最大路径和</h4><p>路径 被定义为一条从树中任意节点出发，沿父节点-子节点连接，达到任意节点的序列。同一个节点在一条路径序列中 至多出现一次 。该路径 至少包含一个 节点，且不一定经过根节点。</p>
<p>路径和 是路径中各节点值的总和。</p>
<p>给你一个二叉树的根节点 root ，返回其 最大路径和 。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这道题一开始的思路是对的，就是递归求出左子树和右子树的最大的路径和，然后进行比较。但是后来发现有个问题就是在计算的过程中可能会出现最大和子路径不连续的情况，所以还得做进一步改进。大体的改进思路就是设置一个全局变量记录递归过程中的最大路径和，但是每一层递归返回的是包含当前结点的路径和（不论当前结点是正数还是负数）。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> max_res = INT_MIN;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left = <span class="built_in">max</span>(<span class="built_in">solve</span>(root-&gt;left), <span class="number">0</span>);</span><br><span class="line">        <span class="type">int</span> right = <span class="built_in">max</span>(<span class="built_in">solve</span>(root-&gt;right), <span class="number">0</span>);</span><br><span class="line">      	<span class="comment">//这里是一个关键，不论根节点是否对最大路径和起到贡献都要加上根节点，防止出现不连续的情况。</span></span><br><span class="line">        <span class="type">int</span> tem_res = left + right + root-&gt;val;</span><br><span class="line">        max_res = <span class="built_in">max</span>(max_res, tem_res);</span><br><span class="line">      	<span class="comment">//这也是一个关键，一条路径不能出现分叉。这里就要视具体题目而定了。</span></span><br><span class="line">        <span class="keyword">return</span> root-&gt;val + <span class="built_in">max</span>(left, right);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxPathSum</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="built_in">solve</span>(root);</span><br><span class="line">        <span class="keyword">return</span> max_res;            </span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="重排链表"><a href="#重排链表" class="headerlink" title="重排链表"></a>重排链表</h4><p>给定一个单链表 L 的头节点 head ，单链表 L 表示为：</p>
<p>L0 → L1 → … → Ln - 1 → Ln<br>请将其重新排列后变为：</p>
<p>L0 → Ln → L1 → Ln - 1 → L2 → Ln - 2 → …<br>不能只是单纯的改变节点内部的值，而是需要实际的进行节点交换。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这道题的关键是如何知道链表的长度以及通过类似索引的方式得到任意结点。</span><br><span class="line">根据这种方式可以知道可以通过vector来记录所有结点来解决。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">reorderList</span><span class="params">(ListNode *head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (head == <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;ListNode *&gt; vec;</span><br><span class="line">        ListNode *node = head;</span><br><span class="line">        <span class="keyword">while</span> (node != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">            vec.<span class="built_in">emplace_back</span>(node);</span><br><span class="line">            node = node-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = vec.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; j) &#123;</span><br><span class="line">            vec[i]-&gt;next = vec[j];</span><br><span class="line">            i++;</span><br><span class="line">            <span class="keyword">if</span> (i == j) &#123;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            vec[j]-&gt;next = vec[i];</span><br><span class="line">            j--;</span><br><span class="line">        &#125;</span><br><span class="line">        vec[i]-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="中序遍历"><a href="#中序遍历" class="headerlink" title="中序遍历"></a>中序遍历</h4><p>递归</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;res, TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left)</span><br><span class="line">            <span class="built_in">solve</span>(res, root-&gt;left);</span><br><span class="line">        res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">        <span class="keyword">if</span>(root-&gt;right)</span><br><span class="line">            <span class="built_in">solve</span>(res, root-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(!root)</span><br><span class="line">            <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;&#125;;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="built_in">solve</span>(res, root);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>迭代</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">迭代的关键是压入左结点时要注意循环的条件不要是左结点是否为空。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">inorderTraversal</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        stack&lt;TreeNode*&gt; stk;</span><br><span class="line">        <span class="keyword">while</span> (root != <span class="literal">nullptr</span> || !stk.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            <span class="keyword">while</span> (root != <span class="literal">nullptr</span>) &#123;</span><br><span class="line">                stk.<span class="built_in">push</span>(root);</span><br><span class="line">                root = root-&gt;left;</span><br><span class="line">            &#125;</span><br><span class="line">            root = stk.<span class="built_in">top</span>();</span><br><span class="line">            stk.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">push_back</span>(root-&gt;val);</span><br><span class="line">            root = root-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="删除链表的倒数第N个结点"><a href="#删除链表的倒数第N个结点" class="headerlink" title="删除链表的倒数第N个结点"></a>删除链表的倒数第N个结点</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这道题不难，就是哨兵的一个应用</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">removeNthFromEnd</span><span class="params">(ListNode* head, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        ListNode* new_node = <span class="keyword">new</span> <span class="built_in">ListNode</span>();</span><br><span class="line">        new_node-&gt;next = head;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        ListNode* tem = new_node;</span><br><span class="line">        <span class="keyword">while</span>(tem) &#123;</span><br><span class="line">            cnt++;</span><br><span class="line">            tem = tem-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        tem = new_node;</span><br><span class="line">        cnt = cnt - n - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(cnt) &#123;</span><br><span class="line">            tem = tem-&gt;next;</span><br><span class="line">            cnt--;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* tem_2 = tem-&gt;next;</span><br><span class="line">        tem-&gt;next = tem_2-&gt;next;</span><br><span class="line">        <span class="keyword">delete</span> tem_2;</span><br><span class="line">        <span class="keyword">return</span> new_node-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="合并区间"><a href="#合并区间" class="headerlink" title="合并区间"></a>合并区间</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">题：以数组 intervals 表示若干个区间的集合，其中单个区间为 intervals[i] = [starti, endi] 。请你合并所有重叠的区间，并返回一个不重叠的区间数组，该数组需恰好覆盖输入中的所有区间。</span><br><span class="line"></span><br><span class="line">这道题首先是对二维数组进行排序，排序之后不断更新列表的第二位。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">merge</span>(vector&lt;vector&lt;<span class="type">int</span>&gt;&gt;&amp; intervals) &#123;</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; res;</span><br><span class="line">        <span class="built_in">sort</span>(intervals.<span class="built_in">begin</span>(), intervals.<span class="built_in">end</span>());</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len = intervals.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(i&lt;len) &#123;</span><br><span class="line">            <span class="type">int</span> first_index = i;</span><br><span class="line">            <span class="type">int</span> second_val = intervals[i][<span class="number">1</span>];</span><br><span class="line">            <span class="keyword">while</span>(i&lt;len &amp;&amp; intervals[i][<span class="number">0</span>]&lt;=second_val) &#123;</span><br><span class="line">                second_val = <span class="built_in">max</span>(intervals[i][<span class="number">1</span>], second_val);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">                </span><br><span class="line">            vector&lt;<span class="type">int</span>&gt; tem;</span><br><span class="line">            tem.<span class="built_in">push_back</span>(intervals[first_index][<span class="number">0</span>]);</span><br><span class="line">            tem.<span class="built_in">push_back</span>(second_val);</span><br><span class="line">            res.<span class="built_in">push_back</span>(tem);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="排序链表"><a href="#排序链表" class="headerlink" title="排序链表"></a>排序链表</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">这道题的关键点是时间复杂度是nlogn，空间复杂度是1，所以应该用归并排序。</span><br><span class="line">链表的归并排序关键点就是找到中间结点进行断链，然后分开进行递归排序。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">sortList</span>(head, <span class="literal">nullptr</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">sortList</span><span class="params">(ListNode* head, ListNode* tail)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(head == <span class="literal">nullptr</span>)</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        <span class="keyword">if</span>(head-&gt;next == tail) &#123;</span><br><span class="line">            head-&gt;next = <span class="literal">nullptr</span>;</span><br><span class="line">            <span class="keyword">return</span> head;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* slow = head, *fast = head;</span><br><span class="line">        <span class="keyword">while</span>(fast!=tail) &#123;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast!=tail)</span><br><span class="line">                fast = fast-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* mid = slow;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">merge</span>(<span class="built_in">sortList</span>(head, mid), <span class="built_in">sortList</span>(mid, tail));<span class="comment">//这里递归是关键</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">ListNode* <span class="title">merge</span><span class="params">(ListNode* tem1, ListNode* tem2)</span> </span>&#123;</span><br><span class="line">        ListNode* res = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">0</span>);</span><br><span class="line">        ListNode* tem = res;<span class="comment">//ListNode* tem1 = head, *tem2 = tail;</span></span><br><span class="line">        <span class="keyword">while</span>(tem1!=<span class="literal">nullptr</span> &amp;&amp; tem2!=<span class="literal">nullptr</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>(tem1-&gt;val &lt;= tem2-&gt;val) &#123;</span><br><span class="line">                tem-&gt;next = tem1;</span><br><span class="line">                tem1 = tem1-&gt;next;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tem-&gt;next = tem2;</span><br><span class="line">                tem2 = tem2-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            tem = tem-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(tem1!=<span class="literal">nullptr</span>)</span><br><span class="line">            tem-&gt;next = tem1;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(tem2!=<span class="literal">nullptr</span>)</span><br><span class="line">            tem-&gt;next = tem2;</span><br><span class="line">        <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="下一个排列"><a href="#下一个排列" class="headerlink" title="下一个排列"></a>下一个排列</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">整数数组的一个 排列  就是将其所有成员以序列或线性顺序排列。</span><br><span class="line"></span><br><span class="line">例如，arr = [1,2,3] ，以下这些都可以视作 arr 的排列：[1,2,3]、[1,3,2]、[3,1,2]、[2,3,1] 。</span><br><span class="line">整数数组的 下一个排列 是指其整数的下一个字典序更大的排列。更正式地，如果数组的所有排列根据其字典顺序从小到大排列在一个容器中，那么数组的 下一个排列 就是在这个有序容器中排在它后面的那个排列。如果不存在下一个更大的排列，那么这个数组必须重排为字典序最小的排列（即，其元素按升序排列）。</span><br><span class="line"></span><br><span class="line">例如，arr = [1,2,3] 的下一个排列是 [1,3,2] 。</span><br><span class="line">类似地，arr = [2,3,1] 的下一个排列是 [3,1,2] 。</span><br><span class="line">而 arr = [3,2,1] 的下一个排列是 [1,2,3] ，因为 [3,2,1] 不存在一个字典序更大的排列。</span><br><span class="line">给你一个整数数组 nums ，找出 nums 的下一个排列。</span><br><span class="line"></span><br><span class="line">必须 原地 修改，只允许使用额外常数空间。</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这道题的关键是找到一个较大的数和一个较小的数，交换两者的位置，然后再进行一次排序（逆序）。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">nextPermutation</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> i = nums.<span class="built_in">size</span>() - <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">while</span> (i &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[i + <span class="number">1</span>]) &#123;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (i &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="type">int</span> j = nums.<span class="built_in">size</span>() - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span> (j &gt;= <span class="number">0</span> &amp;&amp; nums[i] &gt;= nums[j]) &#123;</span><br><span class="line">                j--;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">swap</span>(nums[i], nums[j]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(nums.<span class="built_in">begin</span>() + i + <span class="number">1</span>, nums.<span class="built_in">end</span>());</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="二叉树最大宽度"><a href="#二叉树最大宽度" class="headerlink" title="二叉树最大宽度"></a>二叉树最大宽度</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">层序遍历同时记录每个节点的索引即可。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">widthOfBinaryTree</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">        <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span> res = <span class="number">1</span>;</span><br><span class="line">        vector&lt;pair&lt;TreeNode *, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;&gt; arr;</span><br><span class="line">        arr.<span class="built_in">emplace_back</span>(root, <span class="number">1L</span>);</span><br><span class="line">        <span class="keyword">while</span> (!arr.<span class="built_in">empty</span>()) &#123;</span><br><span class="line">            vector&lt;pair&lt;TreeNode *, <span class="type">unsigned</span> <span class="type">long</span> <span class="type">long</span>&gt;&gt; tmp;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;[node, index] : arr) &#123;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;left) &#123;</span><br><span class="line">                    tmp.<span class="built_in">emplace_back</span>(node-&gt;left, index * <span class="number">2</span>);</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (node-&gt;right) &#123;</span><br><span class="line">                    tmp.<span class="built_in">emplace_back</span>(node-&gt;right, index * <span class="number">2</span> + <span class="number">1</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            res = <span class="built_in">max</span>(res, arr.<span class="built_in">back</span>().second - arr[<span class="number">0</span>].second + <span class="number">1</span>);</span><br><span class="line">            arr = <span class="built_in">move</span>(tmp);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="括号生成"><a href="#括号生成" class="headerlink" title="括号生成"></a>括号生成</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">生成所有的括号组合，重点看一下回溯的写法。</span><br><span class="line">自己在写的时候一直在关注怎么在回溯的过程中进行括号匹配，官方解答并没有进行专门的括号匹配，单纯的回溯也达到的最终的效果，回溯不一定是下表索引，也可以是元素的个数。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">backtrack</span><span class="params">(vector&lt;string&gt;&amp; ans, string&amp; cur, <span class="type">int</span> open, <span class="type">int</span> close, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (cur.<span class="built_in">size</span>() == n * <span class="number">2</span>) &#123;</span><br><span class="line">            ans.<span class="built_in">push_back</span>(cur);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (open &lt; n) &#123;</span><br><span class="line">            cur.<span class="built_in">push_back</span>(<span class="string">&#x27;(&#x27;</span>);</span><br><span class="line">            <span class="built_in">backtrack</span>(ans, cur, open + <span class="number">1</span>, close, n);</span><br><span class="line">            cur.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (close &lt; open) &#123;</span><br><span class="line">            cur.<span class="built_in">push_back</span>(<span class="string">&#x27;)&#x27;</span>);</span><br><span class="line">            <span class="built_in">backtrack</span>(ans, cur, open, close + <span class="number">1</span>, n);</span><br><span class="line">            cur.<span class="built_in">pop_back</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">generateParenthesis</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; result;</span><br><span class="line">        string current;</span><br><span class="line">        <span class="built_in">backtrack</span>(result, current, <span class="number">0</span>, <span class="number">0</span>, n);</span><br><span class="line">        <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="编辑距离"><a href="#编辑距离" class="headerlink" title="编辑距离"></a>编辑距离</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">编辑距离经典题目，只要梳理出字符串不同匹配规则的分支就可以顺利写出代码。</span><br><span class="line">动态规划的形参就是字符串的索引。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> sz[<span class="number">500</span>][<span class="number">500</span>];</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">dp</span><span class="params">(string word1, <span class="type">int</span> m, string word2, <span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(m == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> n + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> m + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">if</span>(sz[m][n]!=<span class="number">-1</span>)</span><br><span class="line">            <span class="keyword">return</span> sz[m][n];</span><br><span class="line">        <span class="keyword">if</span>(word1[m]==word2[n]) &#123;</span><br><span class="line">            sz[m][n] = <span class="built_in">dp</span>(word1, m<span class="number">-1</span>, word2, n<span class="number">-1</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            sz[m][n] = <span class="built_in">min_</span>(</span><br><span class="line">                <span class="built_in">dp</span>(word1, m<span class="number">-1</span>, word2, n) + <span class="number">1</span>,</span><br><span class="line">                <span class="built_in">dp</span>(word1, m, word2, n<span class="number">-1</span>) + <span class="number">1</span>,</span><br><span class="line">                <span class="built_in">dp</span>(word1, m<span class="number">-1</span>, word2, n<span class="number">-1</span>) + <span class="number">1</span></span><br><span class="line">            );</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sz[m][n];</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">min_</span><span class="params">(<span class="type">int</span> a, <span class="type">int</span> b, <span class="type">int</span> c)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">min</span>(a, <span class="built_in">min</span>(b, c));</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minDistance</span><span class="params">(string word1, string word2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = word1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = word2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//int sz[m][n];</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;m; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;n; j++)</span><br><span class="line">                sz[i][j] = <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">dp</span>(word1, m<span class="number">-1</span>, word2, n<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="两个字符串的最长公共子序列"><a href="#两个字符串的最长公共子序列" class="headerlink" title="两个字符串的最长公共子序列"></a>两个字符串的最长公共子序列</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">一般涉及到字符串的动态规划问题，一般就是字符串的索引或者是字符串的长度。</span><br><span class="line">其实和一个字符串的处理大同小异，还是判断当前字符相同怎么样，不同怎么样。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">longestCommonSubsequence</span><span class="params">(string text1, string text2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> m = text1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> n = text2.<span class="built_in">size</span>();</span><br><span class="line">        vector&lt;vector&lt;<span class="type">int</span>&gt;&gt; <span class="built_in">sz</span>(m+<span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">int</span>&gt;(n+<span class="number">1</span>, <span class="number">0</span>));</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=m; i++) &#123;</span><br><span class="line">            <span class="type">char</span> ch1 = text1[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">1</span>; j&lt;=n; j++) &#123;</span><br><span class="line">                <span class="type">char</span> ch2 = text2[j<span class="number">-1</span>];</span><br><span class="line">                <span class="keyword">if</span>(ch1 == ch2) &#123;</span><br><span class="line">                    sz[i][j] = sz[i<span class="number">-1</span>][j<span class="number">-1</span>] + <span class="number">1</span>;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    sz[i][j] = <span class="built_in">max</span>(sz[i<span class="number">-1</span>][j], sz[i][j<span class="number">-1</span>]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> sz[m][n];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="缺失的第一个正数"><a href="#缺失的第一个正数" class="headerlink" title="缺失的第一个正数"></a>缺失的第一个正数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">给你一个未排序的整数数组 nums ，请你找出其中没有出现的最小的正整数。</span><br><span class="line"></span><br><span class="line">请你实现时间复杂度为 O(n) 并且只使用常数级别额外空间的解决方案。</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这道题的关键在时间复杂度，因为是O（n），所以不能用排序，在O（n）之内的时间复杂度基本只有二分查找和哈希，但由于空间复杂度的限制是常数级别，所以这道题采用了原地哈希，非常的巧妙。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">firstMissingPositive</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&lt;=<span class="number">0</span>)  </span><br><span class="line">                nums[i] = n+<span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;n; i++) &#123;</span><br><span class="line">            <span class="type">int</span> num = <span class="built_in">abs</span>(nums[i]);</span><br><span class="line">            <span class="keyword">if</span>(num&lt;=n)</span><br><span class="line">                nums[num<span class="number">-1</span>] = -<span class="built_in">abs</span>(nums[num<span class="number">-1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> i;</span><br><span class="line">        <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;n; i++)</span><br><span class="line">            <span class="keyword">if</span>(nums[i]&gt;<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">return</span> i+<span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="滑动窗口的最大值"><a href="#滑动窗口的最大值" class="headerlink" title="滑动窗口的最大值"></a>滑动窗口的最大值</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 nums，有一个大小为 k 的滑动窗口从数组的最左侧移动到数组的最右侧。你只可以看到在滑动窗口内的 k 个数字。滑动窗口每次只向右移动一位。</span><br><span class="line">返回 滑动窗口中的最大值。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">这道题的关键的滑动窗口的最大值，最大值就要想到优先队列，这道题的做法就是优先队列。</span><br><span class="line">关于优先队列的用法：</span><br><span class="line">#默认大根堆 </span><br><span class="line">priority_queue&lt;<span class="type">int</span>&gt; que;</span><br><span class="line"><span class="meta">#greater是小根堆 </span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,greater&lt;<span class="type">int</span>&gt; &gt; que; </span><br><span class="line"><span class="meta">#less是大根堆</span></span><br><span class="line">priority_queue&lt;<span class="type">int</span>,vector&lt;<span class="type">int</span>&gt;,less&lt;<span class="type">int</span>&gt; &gt; que;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;queue&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;map&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span>&#123;</span><br><span class="line">	<span class="type">int</span> x,y;</span><br><span class="line">&#125;node;</span><br><span class="line"><span class="comment">//自定义堆的排序规则。注意，这里的cmp是结构体，不是函数。 </span></span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">cmp2</span>&#123;</span><br><span class="line">	<span class="function"><span class="type">bool</span> <span class="title">operator</span><span class="params">()</span><span class="params">(pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; p1,pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; p2)</span></span>&#123;</span><br><span class="line">		<span class="comment">//按照第一个元素降序排序,priority_queue的排序规则与sort的规则是相反的。</span></span><br><span class="line">		<span class="keyword">return</span> p1.first&gt;p2.first; </span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">	priority_queue&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;,vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt; &gt;,cmp2 &gt;que;</span><br><span class="line">	que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">5</span>,<span class="number">1</span>));</span><br><span class="line">	que.<span class="built_in">push</span>(<span class="built_in">make_pair</span>(<span class="number">4</span>,<span class="number">2</span>));</span><br><span class="line">	<span class="keyword">while</span>(!que.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		cout&lt;&lt;que.<span class="built_in">top</span>().first&lt;&lt;endl;</span><br><span class="line">		que.<span class="built_in">pop</span>();</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxSlidingWindow</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums, <span class="type">int</span> k)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; q;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> n = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;k; i++)</span><br><span class="line">            q.<span class="built_in">emplace</span>(<span class="built_in">make_pair</span>(nums[i], i));</span><br><span class="line">        res.<span class="built_in">emplace_back</span>(q.<span class="built_in">top</span>().first);</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=k; i&lt;n; i++) &#123;</span><br><span class="line">            q.<span class="built_in">emplace</span>(<span class="built_in">make_pair</span>(nums[i], i));</span><br><span class="line">            <span class="keyword">while</span>(q.<span class="built_in">top</span>().second &lt;= i-k) </span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">            res.<span class="built_in">emplace_back</span>(q.<span class="built_in">top</span>().first);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;; </span><br></pre></td></tr></table></figure>

<h4 id="翻转字符串中的单词"><a href="#翻转字符串中的单词" class="headerlink" title="翻转字符串中的单词"></a>翻转字符串中的单词</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">一些字符串函数：</span><br><span class="line">s.substr(start_index, len)</span><br><span class="line">reverse(s.begin(), s.end())</span><br><span class="line">数字转字符串to_string()</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">reverseWords</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        vector&lt;string&gt; res;</span><br><span class="line">        <span class="keyword">if</span> (s.<span class="built_in">size</span>() == <span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> s;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] == <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">            i++;</span><br><span class="line">        j = i;</span><br><span class="line">        <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>())</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">while</span> (i &lt; s.<span class="built_in">size</span>() &amp;&amp; s[i] != <span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                i++;</span><br><span class="line">            res.<span class="built_in">push_back</span>(s.<span class="built_in">substr</span>(j, i-j));</span><br><span class="line">            <span class="keyword">while</span>(i&lt;s.<span class="built_in">size</span>() &amp;&amp; s[i]==<span class="string">&#x27; &#x27;</span>)</span><br><span class="line">                i++;</span><br><span class="line">            j = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        vector&lt;string&gt;::iterator it = res.<span class="built_in">begin</span>();</span><br><span class="line">        string res_ = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">while</span>(it!=res.<span class="built_in">end</span>()) &#123;</span><br><span class="line">            string tem = *it;</span><br><span class="line">            res_ = res_ + <span class="string">&quot; &quot;</span> + tem;</span><br><span class="line">            it++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res_.<span class="built_in">substr</span>(<span class="number">1</span>, res_.<span class="built_in">size</span>()<span class="number">-1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="最小覆盖子串"><a href="#最小覆盖子串" class="headerlink" title="最小覆盖子串"></a>最小覆盖子串</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">给你一个字符串 s 、一个字符串 t 。返回 s 中涵盖 t 所有字符的最小子串。如果 s 中不存在涵盖 t 所有字符的子串，则返回空字符串 <span class="string">&quot;&quot;</span> 。</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">滑动窗口的妙用，这道题如果是想在O(N)复杂度的情况下实现，就是需要遍历一遍数组，为了找到满足要求的子串，可以通过滑动窗口实现。还有一个关键之处就是以后不要在条件中加入数组大小等之类的计算，在进入循环之前就用一个变量进行记录。先移动右指针知道包含所有的字符，再移动左指针直到实现包含所有字符的最小子串。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    unordered_map &lt;<span class="type">char</span>, <span class="type">int</span>&gt; ori, cnt;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;p: ori) &#123;</span><br><span class="line">            <span class="keyword">if</span> (cnt[p.first] &lt; p.second) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">string <span class="title">minWindow</span><span class="params">(string s, string t)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">const</span> <span class="keyword">auto</span> &amp;c: t) &#123;</span><br><span class="line">            ++ori[c];</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> l = <span class="number">0</span>, r = <span class="number">-1</span>;</span><br><span class="line">        <span class="type">int</span> len = INT_MAX, ansL = <span class="number">-1</span>, ansR = <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">while</span> (r &lt; <span class="built_in">int</span>(s.<span class="built_in">size</span>())) &#123;</span><br><span class="line">            <span class="keyword">if</span> (ori.<span class="built_in">find</span>(s[++r]) != ori.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                ++cnt[s[r]];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">while</span> (<span class="built_in">check</span>() &amp;&amp; l &lt;= r) &#123;</span><br><span class="line">                <span class="keyword">if</span> (r - l + <span class="number">1</span> &lt; len) &#123;</span><br><span class="line">                    len = r - l + <span class="number">1</span>;</span><br><span class="line">                    ansL = l;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (ori.<span class="built_in">find</span>(s[l]) != ori.<span class="built_in">end</span>()) &#123;</span><br><span class="line">                    --cnt[s[l]];</span><br><span class="line">                &#125;</span><br><span class="line">                ++l;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> ansL == <span class="number">-1</span> ? <span class="built_in">string</span>() : s.<span class="built_in">substr</span>(ansL, len);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h4 id="逆序对的个数"><a href="#逆序对的个数" class="headerlink" title="逆序对的个数"></a>逆序对的个数</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">归并的妙用，在无结构的情况下引入了排序的结构，进而使用分支解决</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res_cnt = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">solve</span><span class="params">(vector&lt;<span class="type">int</span>&gt; &amp;nums, <span class="type">int</span> l, <span class="type">int</span> r)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> mid = l + (r - l) / <span class="number">2</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res_l, res_r;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=mid || r&lt;=mid)</span><br><span class="line">            <span class="keyword">return</span> vector&lt;<span class="type">int</span>&gt;&#123;nums[mid]&#125;;</span><br><span class="line">        res_l = <span class="built_in">solve</span>(nums, l, mid);</span><br><span class="line">        res_r = <span class="built_in">solve</span>(nums, mid, r);</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;<span class="built_in">int</span>(res_l.<span class="built_in">size</span>()) &amp;&amp; j&lt;<span class="built_in">int</span>(res_r.<span class="built_in">size</span>())) &#123;</span><br><span class="line">            <span class="keyword">if</span>(res_l[i] &lt;= res_r[j]) &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(res_l[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                res.<span class="built_in">push_back</span>(res_r[j]);</span><br><span class="line">                <span class="type">int</span> tem = res_l.<span class="built_in">size</span>();</span><br><span class="line">                res_cnt = res_cnt + tem -i;<span class="comment">//此处为记录逆序对的个数</span></span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">            </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> flag = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;<span class="built_in">int</span>(res_l.<span class="built_in">size</span>())) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(res_l[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;<span class="built_in">int</span>(res_r.<span class="built_in">size</span>())) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(res_r[j]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">reversePairs</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(len==<span class="number">0</span> || len==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res = <span class="built_in">solve</span>(nums, <span class="number">0</span>, len);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">return</span> res_cnt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="计算右侧小于当前元素的个数（力扣没完全AC，超时）"><a href="#计算右侧小于当前元素的个数（力扣没完全AC，超时）" class="headerlink" title="计算右侧小于当前元素的个数（力扣没完全AC，超时）"></a>计算右侧小于当前元素的个数（力扣没完全AC，超时）</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这道题就是逆序对的升级版，同样是用归并进行逆序的计算，不过这道题还需要记录一下数组中每个元素原始坐标，即索引数组，跟随排序的数组一起变动。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line"></span><br><span class="line">    vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; <span class="built_in">solve</span>(vector&lt;pair&lt;<span class="type">int</span>,<span class="type">int</span>&gt;&gt;&amp; data_pair, <span class="type">int</span> l, <span class="type">int</span> r) &#123;</span><br><span class="line">        <span class="type">int</span> mid = l + (r - l)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span>(l&gt;=mid || r&lt;=mid) &#123;</span><br><span class="line">            <span class="type">int</span> a = data_pair[mid].first;</span><br><span class="line">            <span class="type">int</span> b = data_pair[mid].second;</span><br><span class="line">            <span class="keyword">return</span> vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt;&#123;&#123;a, b&#125;&#125;;</span><br><span class="line">        &#125;</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; sz1 = <span class="built_in">solve</span>(data_pair, l, mid);</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; sz2 = <span class="built_in">solve</span>(data_pair, mid, r);</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; tem;</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>, j = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len1 = sz1.<span class="built_in">size</span>(), len2 = sz2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">while</span>(i&lt;len1 &amp;&amp; j&lt;len2) &#123;</span><br><span class="line">            <span class="keyword">if</span>(sz1[i].first &lt;= sz2[j].first) &#123;</span><br><span class="line">                tem.<span class="built_in">push_back</span>(sz1[i]);</span><br><span class="line">                i++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                tem.<span class="built_in">push_back</span>(sz2[j]);</span><br><span class="line">                <span class="keyword">for</span>(<span class="type">int</span> a=i; a&lt;len1; a++) &#123;</span><br><span class="line">                    res[sz1[a].second]++;</span><br><span class="line">                &#125;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;len1) &#123;</span><br><span class="line">            tem.<span class="built_in">push_back</span>(sz1[i]);</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(j&lt;len2) &#123;</span><br><span class="line">            tem.<span class="built_in">push_back</span>(sz2[j]);</span><br><span class="line">            j++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//cout &lt;&lt; &quot;dddd&quot; &lt;&lt; endl;</span></span><br><span class="line">        <span class="keyword">return</span> tem;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">countSmaller</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        res.<span class="built_in">resize</span>(nums.<span class="built_in">size</span>());</span><br><span class="line">        vector&lt;pair&lt;<span class="type">int</span>, <span class="type">int</span>&gt;&gt; data_pair;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len; i++) &#123;</span><br><span class="line">            data_pair.<span class="built_in">push_back</span>(<span class="built_in">make_pair</span>(nums[i], i));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">solve</span>(data_pair, <span class="number">0</span>, len);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="零钱兑换"><a href="#零钱兑换" class="headerlink" title="零钱兑换"></a>零钱兑换</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">给你一个整数数组 coins ，表示不同面额的硬币；以及一个整数 amount ，表示总金额。</span><br><span class="line"></span><br><span class="line">计算并返回可以凑成总金额所需的 最少的硬币个数 。如果没有任何一种硬币组合能组成总金额，返回 -1 。</span><br><span class="line"></span><br><span class="line">你可以认为每种硬币的数量是无限的。</span><br></pre></td></tr></table></figure>

<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这道题一开始也想到了用dp来做，转移方程也想到了，出问题的地方在边界条件，直接进行一个大小比较就行，不需要考虑-1的处理，对每个amount值进行每一个coins的值的搜索，其中加入记忆化trick，不需要太复杂的操作。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">coinChange</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; coins, <span class="type">int</span> amount)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> MAX = amount + <span class="number">1</span>;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">cnt</span><span class="params">(amount+<span class="number">1</span>, MAX)</span></span>;</span><br><span class="line">        cnt[<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> len = coins.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;=amount; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;len; j++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(coins[j]&lt;=i)</span><br><span class="line">                    cnt[i] = <span class="built_in">min</span>(cnt[i], cnt[i-coins[j]]+<span class="number">1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> cnt[amount]&gt;amount?<span class="number">-1</span>:cnt[amount];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="高精度乘法"><a href="#高精度乘法" class="headerlink" title="高精度乘法"></a>高精度乘法</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">define</span> max 1000000</span></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">string <span class="title">multiply</span><span class="params">(string num1, string num2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> len1 = num1.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> len2 = num2.<span class="built_in">size</span>();</span><br><span class="line">        <span class="type">int</span> len3 = len1 + len2;</span><br><span class="line">        <span class="type">int</span> a[max];</span><br><span class="line">        <span class="type">int</span> b[max];</span><br><span class="line">        <span class="type">int</span> c[<span class="number">2</span>*max]=&#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">reverse</span>(num1.<span class="built_in">begin</span>(), num1.<span class="built_in">end</span>());</span><br><span class="line">        <span class="built_in">reverse</span>(num2.<span class="built_in">begin</span>(), num2.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len1; i++)</span><br><span class="line">            a[i] = num1[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len2; i++)</span><br><span class="line">            b[i] = num2[i] - <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len1; i++) &#123;</span><br><span class="line">            <span class="type">int</span> temp = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=<span class="number">0</span>; j&lt;len2; j++) &#123;</span><br><span class="line">                cout &lt;&lt; a[i] &lt;&lt; <span class="string">&quot; &quot;</span> &lt;&lt; b[j] &lt;&lt; endl;</span><br><span class="line">                c[i+j] = a[i] * b[j] + temp + c[i+j];</span><br><span class="line">                cout &lt;&lt; c[i+j] &lt;&lt; endl;</span><br><span class="line">                temp = c[i+j] / <span class="number">10</span>;</span><br><span class="line">                c[i+j] = c[i+j] % <span class="number">10</span>;</span><br><span class="line">                </span><br><span class="line">            &#125;</span><br><span class="line">            c[i+len2] = temp;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=len3<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">if</span>(len3&gt;<span class="number">1</span> &amp;&amp; c[i]==<span class="number">0</span>)</span><br><span class="line">                len3--;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        string res = <span class="string">&quot;&quot;</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;len3; i++)</span><br><span class="line">            res = res + <span class="built_in">to_string</span>(c[i]);</span><br><span class="line">        <span class="built_in">reverse</span>(res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>());</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="剑指offer"><a href="#剑指offer" class="headerlink" title="剑指offer"></a>剑指offer</h1><ol>
<li>Vector emplace(iter, val)</li>
<li>Vector 截取一部分</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="type">int</span>&gt; Arrs &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;; <span class="comment">// 假设有这么个数组,要截取中间第二个元素到第四个元素：2，3，4</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator Fist = Arrs.<span class="built_in">begin</span>() + <span class="number">1</span>; <span class="comment">// 找到第二个迭代器</span></span><br><span class="line">vector&lt;<span class="type">int</span>&gt;::const_iterator Second = Arrs.<span class="built_in">begin</span>() + <span class="number">2</span>; <span class="comment">// 找到第三个迭代器</span></span><br><span class="line"><span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">Arrs2</span><span class="params">(First, Second)</span></span>; <span class="comment">// 将值直接初始化到Arrs2</span></span><br></pre></td></tr></table></figure>

<ol start="3">
<li>旋转数组的最小数字</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">minNumberInRotateArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt; rotateArray)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> tar = rotateArray[rotateArray.<span class="built_in">size</span>()<span class="number">-1</span>];</span><br><span class="line">        <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> j = rotateArray.<span class="built_in">size</span>()<span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;=j) &#123;</span><br><span class="line">            <span class="type">int</span> mid = i + (j-i)/<span class="number">2</span>;</span><br><span class="line">            <span class="keyword">if</span>(rotateArray[mid]&gt;rotateArray[j])</span><br><span class="line">                i = mid+<span class="number">1</span>;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(rotateArray[mid]&lt;rotateArray[j])</span><br><span class="line">                j = mid;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                j = j - <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> rotateArray[i];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="4">
<li>fill使用</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">一维数组：</span><br><span class="line">  <span class="built_in">fill</span>(sz, sz+<span class="number">10</span>, <span class="number">0</span>)</span><br><span class="line">	<span class="built_in">fill</span>(sz.<span class="built_in">begin</span>(), sz.<span class="built_in">end</span>(), <span class="number">0</span>)</span><br><span class="line">二维数组:</span><br><span class="line">	<span class="built_in">fill</span>(sz, sz+<span class="number">10</span>*<span class="number">10</span>, <span class="number">0</span>)</span><br></pre></td></tr></table></figure>

<ol start="5">
<li>标准快慢指针写法</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">EntryNodeOfLoop</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        ListNode* fast = pHead;</span><br><span class="line">        ListNode* slow = pHead;</span><br><span class="line">        <span class="keyword">while</span>(fast &amp;&amp; fast-&gt;next) &#123;</span><br><span class="line">            fast = fast-&gt;next-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">            <span class="keyword">if</span>(fast==slow)</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(fast==<span class="literal">NULL</span> || fast-&gt;next==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        fast = pHead;</span><br><span class="line">        <span class="keyword">while</span>(fast!=slow) &#123;</span><br><span class="line">            fast = fast-&gt;next;</span><br><span class="line">            slow = slow-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> fast;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="6">
<li>注意边界</li>
<li>删除链表中的重复结点</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">重点面试题，主要是用map记录一下每个节点出现的次数以及哨兵结点的使用。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">ListNode* <span class="title">deleteDuplication</span><span class="params">(ListNode* pHead)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pHead==<span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">nullptr</span>;</span><br><span class="line">        ListNode* res = pHead;</span><br><span class="line">        unordered_map&lt;<span class="type">int</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="keyword">while</span>(res) &#123;</span><br><span class="line">            mp[res-&gt;val]++;</span><br><span class="line">            res = res-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        ListNode* tem = <span class="keyword">new</span> <span class="built_in">ListNode</span>(<span class="number">-1</span>);</span><br><span class="line">        tem-&gt;next = pHead;</span><br><span class="line">        res = tem;</span><br><span class="line">        <span class="keyword">while</span>(tem-&gt;next) &#123;</span><br><span class="line">            <span class="keyword">if</span>(mp[tem-&gt;next-&gt;val]!=<span class="number">1</span>)</span><br><span class="line">                tem-&gt;next = tem-&gt;next-&gt;next;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                tem = tem-&gt;next;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="8">
<li>复杂链表的复制</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">直接暴力解决，先复制一遍正常链表，这里需要用到哨兵结点，再复制一遍随机指针，这里就是两层循环暴力复制。</span><br></pre></td></tr></table></figure>

<ol start="9">
<li>按之之形打印二叉树</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">将队列替换为两个栈，交替入栈。</span><br></pre></td></tr></table></figure>

<ol start="10">
<li>树的子结构</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">dfs+bfs</span><br></pre></td></tr></table></figure>

<ol start="11">
<li>二叉搜索树的后序遍历序列</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">VerifySquenceOfBST</span><span class="params">(vector&lt;<span class="type">int</span>&gt; sequence)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = sequence.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(n == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;    <span class="comment">// 注意审题, 约定空树不是二叉搜索树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check</span>(sequence, <span class="number">0</span>, n - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; sequence, <span class="type">int</span> l, <span class="type">int</span> r)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(l &gt;= r) <span class="keyword">return</span> <span class="literal">true</span>;    <span class="comment">// 若当前子树只有一个节点</span></span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> root = sequence[r];    <span class="comment">// 当前子树的根节点</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">// 划分出右子树</span></span><br><span class="line">        <span class="type">int</span> j = r - <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(j &gt;= <span class="number">0</span> &amp;&amp; sequence[j] &gt; root) j--;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 检查左子树是不是存在大于根节点的数</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = l; i &lt;= j; i++)&#123;</span><br><span class="line">            <span class="keyword">if</span>(sequence[i] &gt; root) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// 分治法检查左子树和右子树</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">check</span>(sequence, l, j) &amp;&amp; <span class="built_in">check</span>(sequence, j + <span class="number">1</span>, r - <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="12">
<li>二叉树中和为某一值的路径</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">hasPathSum</span><span class="params">(TreeNode* root, <span class="type">int</span> sum)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//空节点找不到路径</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="comment">//叶子节点，且路径和为sum</span></span><br><span class="line">        <span class="keyword">if</span>(root-&gt;left == <span class="literal">NULL</span> &amp;&amp; root-&gt;right == <span class="literal">NULL</span> &amp;&amp; sum - root-&gt;val == <span class="number">0</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="comment">//递归进入子节点</span></span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">hasPathSum</span>(root-&gt;left, sum - root-&gt;val) || <span class="built_in">hasPathSum</span>(root-&gt;right, sum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="13">
<li>二叉搜索树与双向链表</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//返回的第一个指针，即为最小值，先定为NULL</span></span><br><span class="line">    TreeNode* head = <span class="literal">NULL</span>;  </span><br><span class="line">    <span class="comment">//中序遍历当前值的上一位，初值为最小值，先定为NULL</span></span><br><span class="line">    TreeNode* pre = <span class="literal">NULL</span>;   </span><br><span class="line">    <span class="function">TreeNode* <span class="title">Convert</span><span class="params">(TreeNode* pRootOfTree)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(pRootOfTree == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="comment">//中序递归，叶子为空则返回</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;     </span><br><span class="line">        <span class="comment">//首先递归到最左最小值   </span></span><br><span class="line">        <span class="built_in">Convert</span>(pRootOfTree-&gt;left); </span><br><span class="line">        <span class="comment">//找到最小值，初始化head与pre</span></span><br><span class="line">        <span class="keyword">if</span>(pre == <span class="literal">NULL</span>)&#123;       </span><br><span class="line">            head = pRootOfTree;</span><br><span class="line">            pre = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//当前节点与上一节点建立连接，将pre设置为当前值</span></span><br><span class="line">        <span class="keyword">else</span>&#123;       </span><br><span class="line">            pre-&gt;right = pRootOfTree;</span><br><span class="line">            pRootOfTree-&gt;left = pre;</span><br><span class="line">            pre = pRootOfTree;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Convert</span>(pRootOfTree-&gt;right);</span><br><span class="line">        <span class="keyword">return</span> head;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="14">
<li>对称的二叉树</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">recursion</span><span class="params">(TreeNode* root1, TreeNode* root2)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">NULL</span> &amp;&amp; root2 == <span class="literal">NULL</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        <span class="keyword">if</span>(root1 == <span class="literal">NULL</span> || root2 == <span class="literal">NULL</span> || root1-&gt;val != root2-&gt;val)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recursion</span>(root1-&gt;left, root2-&gt;right) &amp;&amp; <span class="built_in">recursion</span>(root1-&gt;right, root2-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isSymmetrical</span><span class="params">(TreeNode* pRoot)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">recursion</span>(pRoot, pRoot);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="15">
<li>二叉树最近公共祖先</li>
<li>二叉树中和为某一值的路径个数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="comment">//dfs查询以某节点为根的路径数</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">dfs</span><span class="params">(TreeNode* root, <span class="type">int</span> sum)</span></span>&#123; </span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        <span class="comment">//符合目标值</span></span><br><span class="line">        <span class="keyword">if</span>(sum == root-&gt;val) </span><br><span class="line">            res++;</span><br><span class="line">        <span class="comment">//进入子节点继续找</span></span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;left, sum - root-&gt;val); </span><br><span class="line">        <span class="built_in">dfs</span>(root-&gt;right, sum - root-&gt;val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//dfs 以每个节点作为根查询路径</span></span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">FindPath</span><span class="params">(TreeNode* root, <span class="type">int</span> sum)</span> </span>&#123; </span><br><span class="line">        <span class="comment">//为空则返回</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) </span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="comment">//查询以某节点为根的路径数</span></span><br><span class="line">        <span class="built_in">dfs</span>(root, sum); </span><br><span class="line">        <span class="comment">//以其子节点为新根</span></span><br><span class="line">        <span class="built_in">FindPath</span>(root-&gt;left, sum); </span><br><span class="line">        <span class="built_in">FindPath</span>(root-&gt;right, sum);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="17">
<li>序列化和反序列化</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="comment">//处理序列化的功能函数（递归）</span></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">SerializeFunction</span><span class="params">(TreeNode* root, string&amp; str)</span></span>&#123;</span><br><span class="line">        <span class="comment">//如果指针为空，表示左子节点或右子节点为空，用#表示</span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>)&#123;</span><br><span class="line">            str += <span class="string">&#x27;#&#x27;</span>;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//根节点</span></span><br><span class="line">        string temp = <span class="built_in">to_string</span>(root-&gt;val); </span><br><span class="line">        str += temp + <span class="string">&#x27;!&#x27;</span>;<span class="comment">// 加!，区分节点 </span></span><br><span class="line">        <span class="comment">//左子树</span></span><br><span class="line">        <span class="built_in">SerializeFunction</span>(root-&gt;left, str); </span><br><span class="line">        <span class="comment">//右子树</span></span><br><span class="line">        <span class="built_in">SerializeFunction</span>(root-&gt;right, str);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">char</span>* <span class="title">Serialize</span><span class="params">(TreeNode *root)</span> </span>&#123; </span><br><span class="line">        <span class="comment">//处理空树   </span></span><br><span class="line">        <span class="keyword">if</span>(root == <span class="literal">NULL</span>) </span><br><span class="line">            <span class="keyword">return</span> <span class="string">&quot;#&quot;</span>;</span><br><span class="line">        string res;</span><br><span class="line">        <span class="built_in">SerializeFunction</span>(root, res);</span><br><span class="line">        <span class="comment">//把str转换成char</span></span><br><span class="line">        <span class="type">char</span>* charRes = <span class="keyword">new</span> <span class="type">char</span>[res.<span class="built_in">length</span>() + <span class="number">1</span>];</span><br><span class="line">        <span class="built_in">strcpy</span>(charRes, res.<span class="built_in">c_str</span>());</span><br><span class="line">        charRes[res.<span class="built_in">length</span>()] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> charRes;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//处理反序列化的功能函数（递归）</span></span><br><span class="line">    <span class="function">TreeNode* <span class="title">DeserializeFunction</span><span class="params">(<span class="type">char</span>** str)</span></span>&#123;</span><br><span class="line">        <span class="comment">//到达叶节点时，构建完毕，返回继续构建父节点</span></span><br><span class="line">        <span class="comment">//双**表示取值</span></span><br><span class="line">        <span class="keyword">if</span>(**str == <span class="string">&#x27;#&#x27;</span>)&#123; </span><br><span class="line">            (*str)++;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//数字转换</span></span><br><span class="line">        <span class="type">int</span> val = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(**str != <span class="string">&#x27;!&#x27;</span> &amp;&amp; **str != <span class="string">&#x27;\0&#x27;</span>)&#123;</span><br><span class="line">            val = val * <span class="number">10</span> + ((**str) - <span class="string">&#x27;0&#x27;</span>);</span><br><span class="line">            (*str)++;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* root = <span class="keyword">new</span> <span class="built_in">TreeNode</span>(val);</span><br><span class="line">        <span class="comment">//序列到底了，构建完成</span></span><br><span class="line">        <span class="keyword">if</span>(**str == <span class="string">&#x27;\0&#x27;</span>) </span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            (*str)++;</span><br><span class="line">        <span class="comment">//反序列化与序列化一致，都是前序</span></span><br><span class="line">        root-&gt;left = <span class="built_in">DeserializeFunction</span>(str);  </span><br><span class="line">        root-&gt;right = <span class="built_in">DeserializeFunction</span>(str);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">TreeNode* <span class="title">Deserialize</span><span class="params">(<span class="type">char</span> *str)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//空序列对应空树</span></span><br><span class="line">        <span class="keyword">if</span>(str == <span class="string">&quot;#&quot;</span>)&#123; </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        TreeNode* res = <span class="built_in">DeserializeFunction</span>(&amp;str);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="18">
<li>优先队列实现O（1）删除任意元素</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">用两个优先队列，其中一个存储所有元素，另一个存储被删除的元素，如果两个优先队列的top元素相同则同时出列。</span><br></pre></td></tr></table></figure>

<ol start="19">
<li>字符串子串</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string s.<span class="built_in">substr</span>(start_index, len);</span><br></pre></td></tr></table></figure>

<ol start="20">
<li>滑动窗口的最大值</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">maxInWindows</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; num, <span class="type">unsigned</span> <span class="type">int</span> size)</span> </span>&#123;</span><br><span class="line">        priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;&gt; &gt; q;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">if</span>(size&gt;num.<span class="built_in">size</span>()||size==<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;size; i++)</span><br><span class="line">            q.<span class="built_in">push</span>(num[i]);</span><br><span class="line">        res.<span class="built_in">push_back</span>(q.<span class="built_in">top</span>());</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=size; i&lt;num.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            q.<span class="built_in">push</span>(num[i]);</span><br><span class="line">            <span class="keyword">while</span>(q.<span class="built_in">size</span>()&gt;size&amp;&amp;q.<span class="built_in">top</span>()==num[i-size]) &#123;      </span><br><span class="line">                q.<span class="built_in">pop</span>();</span><br><span class="line">            &#125;</span><br><span class="line">            res.<span class="built_in">push_back</span>(q.<span class="built_in">top</span>());          </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="21">
<li>查找二维数组中的最大值</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Find</span><span class="params">(<span class="type">int</span> target, vector&lt;vector&lt;<span class="type">int</span>&gt; &gt; array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">//优先判断特殊</span></span><br><span class="line">        <span class="keyword">if</span>(array.<span class="built_in">size</span>() == <span class="number">0</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> n = array.<span class="built_in">size</span>();</span><br><span class="line">        <span class="keyword">if</span>(array[<span class="number">0</span>].<span class="built_in">size</span>() == <span class="number">0</span>)  </span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="type">int</span> m = array[<span class="number">0</span>].<span class="built_in">size</span>();</span><br><span class="line">        <span class="comment">//从最左下角的元素开始往左或往上</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = n - <span class="number">1</span>, j = <span class="number">0</span>; i &gt;= <span class="number">0</span> &amp;&amp; j &lt; m; )&#123; </span><br><span class="line">            <span class="comment">//元素较大，往上走</span></span><br><span class="line">            <span class="keyword">if</span>(array[i][j] &gt; target)   </span><br><span class="line">                i--;</span><br><span class="line">            <span class="comment">//元素较小，往右走</span></span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(array[i][j] &lt; target) </span><br><span class="line">                j++;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="22">
<li>字符串全排列（复杂度O（n!））</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">solve</span><span class="params">(string str, <span class="type">int</span> cnt, set&lt;string&gt;&amp;res)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span>(cnt&gt;=str.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            res.<span class="built_in">insert</span>(str);</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=cnt; i&lt;str.<span class="built_in">size</span>(); i++) &#123;</span><br><span class="line">            <span class="built_in">swap</span>(str[i], str[cnt]);</span><br><span class="line">            <span class="built_in">solve</span>(str, cnt+<span class="number">1</span>, res);</span><br><span class="line">            <span class="built_in">swap</span>(str[cnt], str[i]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function">vector&lt;string&gt; <span class="title">Permutation</span><span class="params">(string str)</span> </span>&#123;</span><br><span class="line">        set&lt;string&gt; res;</span><br><span class="line">        <span class="built_in">solve</span>(str, <span class="number">0</span>, res);</span><br><span class="line">        <span class="keyword">return</span> vector&lt;string&gt;&#123;res.<span class="built_in">begin</span>(), res.<span class="built_in">end</span>()&#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="23">
<li>数字序列中的某个数字</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">这道题本身倒是不难，主要是需要注意数字存储需要用到long long，以及一些边界条件需要注意。</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">findNthDigit</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> cnt = <span class="number">9</span>;</span><br><span class="line">        <span class="type">long</span> <span class="type">long</span> str_index = <span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> index = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>(cnt&lt;n) &#123;</span><br><span class="line">            n -= cnt;</span><br><span class="line">            str_index = str_index * <span class="number">10</span>;</span><br><span class="line">            index++;</span><br><span class="line">            cnt = <span class="number">9</span>*str_index*index;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">int</span> num = str_index + (n<span class="number">-1</span>)/index;</span><br><span class="line">        <span class="type">int</span> a = (n<span class="number">-1</span>)%index;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">to_string</span>(num)[a]-<span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="24">
<li>连续子数组的最大和</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">FindGreatestSumOfSubArray</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; array)</span> </span>&#123;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="comment">//记录到下标i为止的最大连续子数组和</span></span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(array.size(), <span class="number">0</span>)</span></span>; </span><br><span class="line">        dp[<span class="number">0</span>] = array[<span class="number">0</span>];</span><br><span class="line">        <span class="type">int</span> maxsum = dp[<span class="number">0</span>];</span><br><span class="line">        <span class="comment">//滑动区间</span></span><br><span class="line">        <span class="type">int</span> left = <span class="number">0</span>, right = <span class="number">0</span>; </span><br><span class="line">        <span class="comment">//记录最长的区间</span></span><br><span class="line">        <span class="type">int</span> resl = <span class="number">0</span>, resr = <span class="number">0</span>; </span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt; array.<span class="built_in">size</span>(); i++)&#123;</span><br><span class="line">            right++;</span><br><span class="line">            <span class="comment">//状态转移：连续子数组和最大值</span></span><br><span class="line">            dp[i] = <span class="built_in">max</span>(dp[i - <span class="number">1</span>] + array[i], array[i]); </span><br><span class="line">            <span class="comment">//区间新起点</span></span><br><span class="line">            <span class="keyword">if</span>(dp[i - <span class="number">1</span>] + array[i] &lt; array[i])</span><br><span class="line">                left = right;</span><br><span class="line">            <span class="comment">//更新最大值</span></span><br><span class="line">            <span class="keyword">if</span>(dp[i] &gt; maxsum || dp[i] == maxsum &amp;&amp; (right - left + <span class="number">1</span>) &gt; (resr - resl + <span class="number">1</span>))&#123; </span><br><span class="line">                maxsum = dp[i];</span><br><span class="line">                resl = left;</span><br><span class="line">                resr = right;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//取数组</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = resl; i &lt;= resr; i++) </span><br><span class="line">            res.<span class="built_in">push_back</span>(array[i]);</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="25">
<li>正则表达式匹配</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">match</span><span class="params">(string str, string pattern)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n1 = str.<span class="built_in">length</span>();</span><br><span class="line">        <span class="type">int</span> n2 = pattern.<span class="built_in">length</span>();</span><br><span class="line">        <span class="comment">//dp[i][j]表示str前i个字符和pattern前j个字符是否匹配</span></span><br><span class="line">        vector&lt;vector&lt;<span class="type">bool</span>&gt; &gt; <span class="built_in">dp</span>(n1 + <span class="number">1</span>, <span class="built_in">vector</span>&lt;<span class="type">bool</span>&gt;(n2 + <span class="number">1</span>, <span class="literal">false</span>)); </span><br><span class="line">        <span class="comment">//两个都为空串自然匹配</span></span><br><span class="line">        dp[<span class="number">0</span>][<span class="number">0</span>] = <span class="literal">true</span>; </span><br><span class="line">        <span class="comment">//初始化str为空的情况，字符串下标从1开始</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">2</span>; i &lt;= n2; i++)&#123; </span><br><span class="line">            <span class="comment">//可以让自己前面个字符重复0次</span></span><br><span class="line">            <span class="keyword">if</span>(pattern[i - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>) </span><br><span class="line">                <span class="comment">//与再前一个能够匹配空串有关</span></span><br><span class="line">                dp[<span class="number">0</span>][i] = dp[<span class="number">0</span>][i - <span class="number">2</span>]; </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//遍历str每个长度</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">1</span>; i &lt;= n1; i++)&#123; </span><br><span class="line">            <span class="comment">//遍历pattern每个长度</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j = <span class="number">1</span>; j &lt;= n2; j++)&#123; </span><br><span class="line">                <span class="comment">//当前字符不为*，用.去匹配或者字符直接相同</span></span><br><span class="line">                <span class="keyword">if</span>(pattern[j - <span class="number">1</span>] != <span class="string">&#x27;*&#x27;</span> &amp;&amp; (pattern[j - <span class="number">1</span>] == <span class="string">&#x27;.&#x27;</span> || pattern[j - <span class="number">1</span>] == str[i - <span class="number">1</span>]))&#123; </span><br><span class="line">                      dp[i][j] = dp[i - <span class="number">1</span>][j - <span class="number">1</span>];</span><br><span class="line">                <span class="comment">//当前的字符为*</span></span><br><span class="line">                &#125;<span class="keyword">else</span> <span class="keyword">if</span>(j &gt;= <span class="number">2</span> &amp;&amp; pattern[j - <span class="number">1</span>] == <span class="string">&#x27;*&#x27;</span>)&#123; </span><br><span class="line">                    <span class="comment">//若是前一位为.或者前一位可以与这个数字匹配</span></span><br><span class="line">                    <span class="keyword">if</span>(pattern[j - <span class="number">2</span>] == <span class="string">&#x27;.&#x27;</span> || pattern[j - <span class="number">2</span>] == str[i - <span class="number">1</span>]) </span><br><span class="line">                        <span class="comment">//转移情况</span></span><br><span class="line">                        dp[i][j] = dp[i - <span class="number">1</span>][j] || dp[i][j - <span class="number">2</span>];  </span><br><span class="line">                    <span class="keyword">else</span></span><br><span class="line">                        <span class="comment">//不匹配</span></span><br><span class="line">                        dp[i][j] = dp[i][j - <span class="number">2</span>]; </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[n1][n2];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<ol start="26">
<li>不用加减乘除做加法</li>
</ol>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1.按位与来判断进位位</span><br><span class="line">2.按位异或来进行相应位加法</span><br><span class="line">3.按位或来进行1和2的结果加</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Add</span><span class="params">(<span class="type">int</span> num1, <span class="type">int</span> num2)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> n1 = (num1&amp;num2)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> n2 = (num1^num2);</span><br><span class="line">        <span class="keyword">while</span>(n1&amp;n2) &#123;</span><br><span class="line">            num1 = n1;</span><br><span class="line">            num2 = n2;</span><br><span class="line">            n1 = (num1&amp;num2)&lt;&lt;<span class="number">1</span>;</span><br><span class="line">            n2 = (num1^num2);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n1|n2;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="27">
<li>矩形覆盖</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">rectCover</span><span class="params">(<span class="type">int</span> number)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(<span class="number">39</span>, <span class="number">0</span>)</span></span>;</span><br><span class="line">        dp[<span class="number">1</span>] = <span class="number">1</span>;</span><br><span class="line">        dp[<span class="number">2</span>] = <span class="number">2</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">3</span>; i&lt;=<span class="number">38</span>; i++)</span><br><span class="line">            dp[i] = dp[i<span class="number">-1</span>] + dp[i<span class="number">-2</span>];</span><br><span class="line">        <span class="keyword">return</span> dp[number];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="28">
<li>二进制中1的个数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">     <span class="function"><span class="type">int</span>  <span class="title">NumberOf1</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">         <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">         <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>; i&lt;<span class="number">32</span>; i++) &#123;</span><br><span class="line">             <span class="keyword">if</span>((n &amp; (<span class="number">1</span>&lt;&lt;i))!=<span class="number">0</span>)</span><br><span class="line">                cnt++;</span><br><span class="line">         &#125;</span><br><span class="line">         <span class="keyword">return</span> cnt;</span><br><span class="line">     &#125;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="29">
<li>求1+2+…+n</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">Sum_Solution</span><span class="params">(<span class="type">int</span> n)</span> </span>&#123;</span><br><span class="line">        n &amp;&amp; (n += <span class="built_in">Sum_Solution</span>(n<span class="number">-1</span>));</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="30">
<li>O(1)空间复杂度求一个数组中的两个只出现一次的数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">FindNumsAppearOnce</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; array)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> x = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> val:array)</span><br><span class="line">            x ^= val;</span><br><span class="line">        <span class="type">int</span> n = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">while</span>((n&amp;x)==<span class="number">0</span>)</span><br><span class="line">            n = n&lt;&lt;<span class="number">1</span>;</span><br><span class="line">        <span class="type">int</span> a = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> b = <span class="number">0</span>;</span><br><span class="line">        vector&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> val: array) &#123;</span><br><span class="line">            <span class="keyword">if</span>(val&amp;n) &#123;</span><br><span class="line">                a ^= val;</span><br><span class="line">            &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">                b ^= val;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(a&lt;b) &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(a);</span><br><span class="line">            res.<span class="built_in">push_back</span>(b);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            res.<span class="built_in">push_back</span>(b);</span><br><span class="line">            res.<span class="built_in">push_back</span>(a);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="31">
<li>最长不包含重复字符的子字符串</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">lengthOfLongestSubstring</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        unordered_map&lt;<span class="type">char</span>, <span class="type">int</span>&gt; mp;</span><br><span class="line">        <span class="type">int</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> left, right;</span><br><span class="line">        <span class="keyword">for</span>(left=<span class="number">0</span>, right=<span class="number">0</span>; right&lt;s.<span class="built_in">size</span>(); right++) &#123;</span><br><span class="line">            mp[s[right]]++;</span><br><span class="line">            <span class="keyword">while</span>(mp[s[right]]&gt;<span class="number">1</span>)</span><br><span class="line">                mp[s[left++]]--;</span><br><span class="line">            res = <span class="built_in">max</span>(res, (right-left+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="32">
<li>把数字翻译成字符串</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">solve</span><span class="params">(string nums)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="type">int</span> len = nums.<span class="built_in">size</span>();</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">dp</span><span class="params">(len+<span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">0</span>]==<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(nums==<span class="string">&quot;10&quot;</span>||nums==<span class="string">&quot;20&quot;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;nums.<span class="built_in">size</span>(); i++)</span><br><span class="line">            <span class="keyword">if</span>(nums[i]==<span class="string">&#x27;0&#x27;</span>)</span><br><span class="line">                <span class="keyword">if</span>(nums[i<span class="number">-1</span>]!=<span class="string">&#x27;1&#x27;</span>&amp;&amp;nums[i<span class="number">-1</span>]!=<span class="string">&#x27;2&#x27;</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">2</span>; i&lt;=len; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span>((nums[i - <span class="number">2</span>] == <span class="string">&#x27;1&#x27;</span> &amp;&amp; nums[i<span class="number">-1</span>] != <span class="string">&#x27;0&#x27;</span>) || (nums[i<span class="number">-2</span>] == <span class="string">&#x27;2&#x27;</span> &amp;&amp; nums[i<span class="number">-1</span>] &gt; <span class="string">&#x27;0&#x27;</span> &amp;&amp; nums[i<span class="number">-1</span>] &lt; <span class="string">&#x27;7&#x27;</span>))</span><br><span class="line">               dp[i] = dp[i - <span class="number">1</span>] + dp[i - <span class="number">2</span>];</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                dp[i] = dp[i - <span class="number">1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> dp[len];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="33">
<li>数据流中的中位数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, greater&lt;&gt; &gt; q1;</span><br><span class="line">    priority_queue&lt;<span class="type">int</span>, vector&lt;<span class="type">int</span>&gt;, less&lt;&gt; &gt; q2;</span><br><span class="line">    </span><br><span class="line">    <span class="type">int</span> size = <span class="number">0</span>;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Insert</span><span class="params">(<span class="type">int</span> num)</span> </span>&#123;</span><br><span class="line">        q1.<span class="built_in">push</span>(num);</span><br><span class="line">        q2.<span class="built_in">push</span>(q1.<span class="built_in">top</span>());</span><br><span class="line">        q1.<span class="built_in">pop</span>();</span><br><span class="line">        <span class="keyword">if</span>(q2.<span class="built_in">size</span>()&gt;q1.<span class="built_in">size</span>()) &#123;</span><br><span class="line">            q1.<span class="built_in">push</span>(q2.<span class="built_in">top</span>());</span><br><span class="line">            q2.<span class="built_in">pop</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="type">double</span> <span class="title">GetMedian</span><span class="params">()</span> </span>&#123; </span><br><span class="line">        <span class="keyword">return</span> q1.<span class="built_in">size</span>()&gt;q2.<span class="built_in">size</span>()?<span class="built_in">double</span>(q1.<span class="built_in">top</span>()):<span class="built_in">double</span>(q1.<span class="built_in">top</span>()+q2.<span class="built_in">top</span>())/<span class="number">2</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="34">
<li>礼物的最大价值</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">   </span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">maxValue</span><span class="params">(vector&lt;vector&lt;<span class="type">int</span>&gt; &gt;&amp; grid)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// write code here</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=grid.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="type">int</span> j=grid[<span class="number">0</span>].<span class="built_in">size</span>()<span class="number">-1</span>; j&gt;=<span class="number">0</span>; j--) &#123;</span><br><span class="line">                <span class="type">int</span> max_ = -INT_MAX;</span><br><span class="line">                <span class="keyword">if</span>((i+<span class="number">1</span>)&lt;grid.<span class="built_in">size</span>()&amp;&amp;(i+<span class="number">1</span>)&lt;grid.<span class="built_in">size</span>())</span><br><span class="line">                    max_ = <span class="built_in">max</span>(max_, grid[i+<span class="number">1</span>][j]);</span><br><span class="line">                <span class="keyword">if</span>((j+<span class="number">1</span>)&lt;grid[<span class="number">0</span>].<span class="built_in">size</span>()&amp;&amp;(j+<span class="number">1</span>)&lt;grid[<span class="number">0</span>].<span class="built_in">size</span>()) </span><br><span class="line">                    max_ = <span class="built_in">max</span>(max_, grid[i][j+<span class="number">1</span>]);</span><br><span class="line">                grid[i][j] = <span class="built_in">max</span>(grid[i][j], grid[i][j]+max_);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> grid[<span class="number">0</span>][<span class="number">0</span>];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="35">
<li>构建乘积数组</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">multiply</span><span class="params">(<span class="type">const</span> vector&lt;<span class="type">int</span>&gt;&amp; A)</span> </span>&#123;</span><br><span class="line">        <span class="function">vector&lt;<span class="type">int</span>&gt; <span class="title">res</span><span class="params">(A.size(), <span class="number">1</span>)</span></span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">1</span>; i&lt;A.<span class="built_in">size</span>(); i++)</span><br><span class="line">            res[i] = res[i<span class="number">-1</span>] * A[i<span class="number">-1</span>];</span><br><span class="line">        <span class="type">int</span> tem = <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="type">int</span> i=A.<span class="built_in">size</span>()<span class="number">-1</span>; i&gt;=<span class="number">0</span>; i--) &#123;</span><br><span class="line">            res[i] *= tem;</span><br><span class="line">            tem = tem * A[i];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol start="36">
<li>数组中出现次数大于等于数组长度一半的数</li>
</ol>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">int</span> <span class="title">majorityElement</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; nums)</span> </span>&#123;</span><br><span class="line">        <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">        <span class="type">int</span> ans = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">auto</span> val: nums) &#123;</span><br><span class="line">            <span class="keyword">if</span>(cnt==<span class="number">0</span>) &#123;</span><br><span class="line">                ans = val;</span><br><span class="line">                cnt++;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="keyword">if</span>(ans==val)</span><br><span class="line">                    cnt++;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    cnt--;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>



<h1 id="卜算复习"><a href="#卜算复习" class="headerlink" title="卜算复习"></a>卜算复习</h1><h2 id="分治算法"><a href="#分治算法" class="headerlink" title="分治算法"></a>分治算法</h2><p>主定理：</p>
<p><img src="https://gitee.com/calcium-oxide/typora_pic/raw/master/typora/202212242203933.png"></p>
<ol>
<li>归并排序</li>
<li>逆序对个数</li>
</ol>
<p>在归并排序的基础上加上逆序对个数的计算</p>
<img src="https://gitee.com/calcium-oxide/typora_pic/raw/master/typora/202212242204522.png" style="zoom:50%;" />

<img src="https://gitee.com/calcium-oxide/typora_pic/raw/master/typora/202212242204523.png" style="zoom:50%;" />

<p>排序的过程其实就是减少逆序对的过程，在中间记录了逆序对的个数就相当于记录了所有的逆序对个数</p>
<ol start="3">
<li>快速排序</li>
</ol>
<p>通过期望是可以得到快速排序的时间复杂度是$O(nlogn)$的</p>
<ol start="4">
<li>乘法问题</li>
</ol>
<p>Karatsuba </p>
<p><img src="https://gitee.com/calcium-oxide/typora_pic/raw/master/typora/202212242204525.png"></p>
<p>乘法问题可以对数进行数位拆分计算，可以降低复杂度。对于 n 很大时，Karatsuba 的算法效果是很明显的。但是当 n 的规模比较小时， 额外的移位和加法操作将使这个算法变慢。当使用快速傅立叶变换的技术，乘法时间 复杂度是 O(n log n) 。</p>
<p><em>扩展除法：</em>（牛顿迭代法）</p>
<img src="https://gitee.com/calcium-oxide/typora_pic/raw/master/typora/202212242204526.png" style="zoom:50%;" />

<img src="https://gitee.com/calcium-oxide/typora_pic/raw/master/typora/202212242204527.png" style="zoom:50%;" />



<ol start="5">
<li>矩阵乘法</li>
</ol>
<p>Strassen 算法</p>
<p>最原始的矩阵乘法的时间复杂度是$O(n^3)$</p>
<img src="../pic/bu_review_6.png" style="zoom:50%;" />

<ol start="6">
<li>最近点对问题</li>
</ol>
<img src="../pic/bu_review_7.png" style="zoom:50%;" />

<img src="../pic/bu_review_8.png" style="zoom:50%;" />

<img src="../pic/bu_review_9.png" style="zoom:50%;" />

<p>这里的解决方案其实就是分治，重点解决的部分是处在两个平面之间的点。算法提升的部分其实就是将每次递归中的排序换成归并排序中维持一个排序序列，合并的过程就是$O(n)$</p>
<h2 id="动态规划"><a href="#动态规划" class="headerlink" title="动态规划"></a>动态规划</h2><ol>
<li>矩阵链式乘法</li>
</ol>
<p>动态规划本质上是一个多步决策过程，每一步决策对应了多种情况，枚举所有情况观察子问题的形式就可以得到子问题的一般形式即递归表达式（是否满足最优子结构）</p>
<ol start="2">
<li><p>0&#x2F;1背包问题</p>
</li>
<li><p>序列的连配问题（有点类似编辑距离）</p>
</li>
<li><p>图上递归问题</p>
</li>
</ol>
<p>贪心是动态规划的一个加强版本，是给定了一个特殊条件后不需要枚举的动态规划</p>
<h2 id="贪心"><a href="#贪心" class="headerlink" title="贪心"></a>贪心</h2><h2 id="线性规划"><a href="#线性规划" class="headerlink" title="线性规划"></a>线性规划</h2><h2 id="网络流"><a href="#网络流" class="headerlink" title="网络流"></a>网络流</h2>
            
        </div>
        <div class="page-template-comments">
            
        </div>
    </div>
</div>


                
            </div>

        </div>

        <div class="page-main-content-bottom">
            <footer class="footer">
    <div class="info-container">
        <div class="copyright-info info-item">
            &copy;
            
              <span>2020</span>
              -
            
            2022&nbsp;<i class="fas fa-heart icon-animate"></i>&nbsp;<a href="/">calcium_oxide</a>
        </div>
        
            <script async  src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script>
            <div class="website-count info-item">
                
                
            </div>
        
        <div class="theme-info info-item">
            Powered by <a target="_blank" href="https://hexo.io">Hexo</a>&nbsp;|&nbsp;Theme&nbsp;<a class="theme-version" target="_blank" href="https://github.com/XPoet/hexo-theme-keep">Keep v3.4.5</a>
        </div>
        
        
    </div>
</footer>

        </div>
    </div>

    

    <div class="right-bottom-side-tools">
        <div class="side-tools-container">
    <ul class="side-tools-list">
        <li class="tools-item tool-font-adjust-plus flex-center">
            <i class="fas fa-search-plus"></i>
        </li>

        <li class="tools-item tool-font-adjust-minus flex-center">
            <i class="fas fa-search-minus"></i>
        </li>

        <li class="tools-item tool-expand-width flex-center">
            <i class="fas fa-arrows-alt-h"></i>
        </li>

        <li class="tools-item tool-dark-light-toggle flex-center">
            <i class="fas fa-moon"></i>
        </li>

        <!-- rss -->
        

        
            <li class="tools-item tool-scroll-to-top flex-center">
                <i class="fas fa-arrow-up"></i>
            </li>
        

        <li class="tools-item tool-scroll-to-bottom flex-center">
            <i class="fas fa-arrow-down"></i>
        </li>
    </ul>

    <ul class="exposed-tools-list">
        <li class="tools-item tool-toggle-show flex-center">
            <i class="fas fa-cog fa-spin"></i>
        </li>
        
    </ul>
</div>

    </div>

    

    <div class="image-viewer-container">
    <img src="">
</div>


    
        <div class="search-pop-overlay">
    <div class="popup search-popup">
        <div class="search-header">
          <span class="search-input-field-pre">
            <i class="fas fa-keyboard"></i>
          </span>
            <div class="search-input-container">
                <input autocomplete="off"
                       autocorrect="off"
                       autocapitalize="off"
                       placeholder="Search..."
                       spellcheck="false"
                       type="search"
                       class="search-input"
                >
            </div>
            <span class="popup-btn-close">
                <i class="fas fa-times"></i>
            </span>
        </div>
        <div id="search-result">
            <div id="no-result">
                <i class="fas fa-spinner fa-pulse fa-5x fa-fw"></i>
            </div>
        </div>
    </div>
</div>

    

</main>




<script src="/js/utils.js"></script>

<script src="/js/main.js"></script>

<script src="/js/header-shrink.js"></script>

<script src="/js/back2top.js"></script>

<script src="/js/dark-light-toggle.js"></script>



    
<script src="/js/local-search.js"></script>




    
<script src="/js/code-copy.js"></script>





<div class="post-scripts">
    
</div>



</body>
</html>
